{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to M3 - Programming What is that? It is a Java guide made from IntelliJ Support Courses.","title":"Home"},{"location":"#welcome-to-m3-programming","text":"","title":"Welcome to M3 - Programming"},{"location":"#what-is-that","text":"It is a Java guide made from IntelliJ Support Courses.","title":"What is that?"},{"location":"1.1.introduction/","text":"Introduction Java is a general-purpose object-oriented programming language originally developed by Sun Microsystems (which has since been acquired by Oracle Corporation). It declares the principle \"write once, run anywhere\" (WORA) meaning a Java application can be executed on any platform where a Java Virtual Machine (JVM) is installed. Java has been one of the most popular programming languages for many years. According to the TIOBE index , it is in the first position. The applicability of the language allows developers to write large client-server web applications, modern desktop and mobile applications, useful frameworks, and libraries. Short history The Java language project was initiated in 1991 by James Gosling and others. In the beginning, the language was called \"Oak\". Sun Microsystems released the Java 1.0 in 1995. In 2014 Java 8 was released. This version introduced partial support for functional programming and some other updates. To date, the latest version is Java 9. The first stable release of Java 9 was on September 21, 2017. Some important features of Java Let's consider several important features of Java. Platform independence: The compiler converts the source code to bytecode, and, then, the Java Virtual Machine (JVM) executes the bytecode. Each operating system has a different JVM, but every JVM can execute the bytecode, therefore, it works on Windows, Linux, Mac OS and other platforms. So, a program that is written and compiled on one platform can run on another platform. It makes the Java platform completely independent. Simple and clear syntax: Java has syntax like C/C++ and C#. Many syntax elements of the language are readable and widely used in programming. Multi-paradigm: Java is primarily an object-oriented and imperative programming language where almost everything is an object of a class (type). We can consider a typical Java program as a set of interacting objects. The objects can represent entities from the real world or some kind of programming abstractions. When we write a program, we explain how the objects should interact with each others. Actually, Java also supports multiple modern programming paradigms including generic programming, concurrent programming, functional programming (partially supported) and others. Garbage collector: It performs automatic memory cleaning of unused objects at runtime. Built-in multithreading: Java supports multithreading at the language and the standard library levels. It allows concurrent and parallel execution of several parts of a Java program. For more features see here Programming and running processes You will write source code in plain-text files with a .java extension. The files will be compiled into .class files (bytecode) by the javac compiler. To run an application you will use the java tool. The tool can start a .class file with the main method and even whole JAR with multiple classes. Also, it's possible to write bytecode directly but this is not considered in the topic. The following picture shows the very simplified process of writing and running programs using Java: A Java developer writes a program in a text file with the .java extension. The program may include a lot of such files. Then the compiler (usually, javac) translates the program into a .class file containing the bytecode of the program. After, the JVM executes the program giving low-level commands to the computer. Here, the computer is an abstraction that may be a server, PC or even a mobile device. It includes an operating system and a hardware. Actually, the processes are more complex than the image shows. It is important to note the following: the part before JVM is platform independent, the part after the JVM is platform dependent.","title":"Intro"},{"location":"1.1.introduction/#introduction","text":"Java is a general-purpose object-oriented programming language originally developed by Sun Microsystems (which has since been acquired by Oracle Corporation). It declares the principle \"write once, run anywhere\" (WORA) meaning a Java application can be executed on any platform where a Java Virtual Machine (JVM) is installed. Java has been one of the most popular programming languages for many years. According to the TIOBE index , it is in the first position. The applicability of the language allows developers to write large client-server web applications, modern desktop and mobile applications, useful frameworks, and libraries.","title":"Introduction"},{"location":"1.1.introduction/#short-history","text":"The Java language project was initiated in 1991 by James Gosling and others. In the beginning, the language was called \"Oak\". Sun Microsystems released the Java 1.0 in 1995. In 2014 Java 8 was released. This version introduced partial support for functional programming and some other updates. To date, the latest version is Java 9. The first stable release of Java 9 was on September 21, 2017.","title":"Short history"},{"location":"1.1.introduction/#some-important-features-of-java","text":"Let's consider several important features of Java. Platform independence: The compiler converts the source code to bytecode, and, then, the Java Virtual Machine (JVM) executes the bytecode. Each operating system has a different JVM, but every JVM can execute the bytecode, therefore, it works on Windows, Linux, Mac OS and other platforms. So, a program that is written and compiled on one platform can run on another platform. It makes the Java platform completely independent. Simple and clear syntax: Java has syntax like C/C++ and C#. Many syntax elements of the language are readable and widely used in programming. Multi-paradigm: Java is primarily an object-oriented and imperative programming language where almost everything is an object of a class (type). We can consider a typical Java program as a set of interacting objects. The objects can represent entities from the real world or some kind of programming abstractions. When we write a program, we explain how the objects should interact with each others. Actually, Java also supports multiple modern programming paradigms including generic programming, concurrent programming, functional programming (partially supported) and others. Garbage collector: It performs automatic memory cleaning of unused objects at runtime. Built-in multithreading: Java supports multithreading at the language and the standard library levels. It allows concurrent and parallel execution of several parts of a Java program. For more features see here","title":"Some important features of Java"},{"location":"1.1.introduction/#programming-and-running-processes","text":"You will write source code in plain-text files with a .java extension. The files will be compiled into .class files (bytecode) by the javac compiler. To run an application you will use the java tool. The tool can start a .class file with the main method and even whole JAR with multiple classes. Also, it's possible to write bytecode directly but this is not considered in the topic. The following picture shows the very simplified process of writing and running programs using Java: A Java developer writes a program in a text file with the .java extension. The program may include a lot of such files. Then the compiler (usually, javac) translates the program into a .class file containing the bytecode of the program. After, the JVM executes the program giving low-level commands to the computer. Here, the computer is an abstraction that may be a server, PC or even a mobile device. It includes an operating system and a hardware. Actually, the processes are more complex than the image shows. It is important to note the following: the part before JVM is platform independent, the part after the JVM is platform dependent.","title":"Programming and running processes"},{"location":"1.10.typecasting/","text":"Type casting There are two kinds of casting of primitive types: implicit and explicit. The first kind is performed automatically by the Java compiler, the second type - only by a programmer. Implicit casting The compiler automatically performs casting when the target type is wider than source type: There is no loss of information because the target type is wider than the source type. Examples: int intVal = 8; long longVal = intVal + 1; // implicit casting from int to long double doubleVal = longVal; // implicit casting from long to double Explicit casting The explicit casting is performed by a programmer when the target type is narrower than the source type. This kind of casting may lose information about the overall magnitude of a numeric value and may also lose precision. Sometimes this can be the desired behavior. Any type casting not presented in the picture above requires explicit casting, for example: double -> int, long -> char. Examples: double d = 2.00003; long l = (long) d; // it loses the fractional part int i = (int) l; // explicit type casting required int val = (int) (1 + 2L + 3); // requires explicit casting because the result is long When performing explicit casting, type overflow is possible. It is a situation when a value is too large to be written to a type: long maxLong = Long.MAX_VALUE; int overflow = (int) maxLong; // int variable can't store this value, the result is -1 More information can be found in Java SE Specification.","title":"Typecasting"},{"location":"1.10.typecasting/#type-casting","text":"There are two kinds of casting of primitive types: implicit and explicit. The first kind is performed automatically by the Java compiler, the second type - only by a programmer.","title":"Type casting"},{"location":"1.10.typecasting/#implicit-casting","text":"The compiler automatically performs casting when the target type is wider than source type: There is no loss of information because the target type is wider than the source type. Examples: int intVal = 8; long longVal = intVal + 1; // implicit casting from int to long double doubleVal = longVal; // implicit casting from long to double","title":"Implicit casting"},{"location":"1.10.typecasting/#explicit-casting","text":"The explicit casting is performed by a programmer when the target type is narrower than the source type. This kind of casting may lose information about the overall magnitude of a numeric value and may also lose precision. Sometimes this can be the desired behavior. Any type casting not presented in the picture above requires explicit casting, for example: double -> int, long -> char. Examples: double d = 2.00003; long l = (long) d; // it loses the fractional part int i = (int) l; // explicit type casting required int val = (int) (1 + 2L + 3); // requires explicit casting because the result is long When performing explicit casting, type overflow is possible. It is a situation when a value is too large to be written to a type: long maxLong = Long.MAX_VALUE; int overflow = (int) maxLong; // int variable can't store this value, the result is -1 More information can be found in Java SE Specification.","title":"Explicit casting"},{"location":"1.11.format/","text":"String formatting There are three methods to format : String.format(): to format a String String output = String.format(\"My name is %s and I am %d years old\", \"Joe\", 35); printf(): to format the console output System.out.printf(\"My name is %s. I'm %d years old and I'm from %s\", \"Jane\", 35, \"London\"); Formatter object linked to a StringBuilder. ( Java API Info ) StringBuilder sb = new StringBuilder(); Formatter ft = new Formatter(sb); ft.format(\"PI = %f%n\", Math.PI); System.out.println(sb.toString()); Format Specifiers Here are the most common conversion specifiers supported in Java: %d: decimal integer (includes byte, short, int, long anb bigint) %f: floating point (includes float and double) %c: unicode character %s: String %n: line separator Argument Index An argument index is specified as a number ending with a \u201c$\u201d after the \u201c%\u201d and selects the specified argument in the argument list. System.out.printf(\"%2$s\",\"Hello\",\"world\",\"!\"); //prints \"world\" System.out.printf(\"%4$2s %3$2s %2$2s %1$2s\", \"a\", \"b\", \"c\", \"d\") //prints \"d c b a\" Examples String.format(\"%d\", 15); //prints: 15 String.format(\"%20d\", 15); //right justify text: 15 String.format(\"%-20d\", 15); //left justify text: 15 String.format(\"%020d\", 15); //prints: 0000000000000000015 System.out.printf(\"%3$20s %1$10s %2$10s\\n\", \"Hora\", \"Minut\",\"Nom\"); //prints: Nom Hora Minut More info","title":"Format"},{"location":"1.11.format/#string-formatting","text":"There are three methods to format : String.format(): to format a String String output = String.format(\"My name is %s and I am %d years old\", \"Joe\", 35); printf(): to format the console output System.out.printf(\"My name is %s. I'm %d years old and I'm from %s\", \"Jane\", 35, \"London\"); Formatter object linked to a StringBuilder. ( Java API Info ) StringBuilder sb = new StringBuilder(); Formatter ft = new Formatter(sb); ft.format(\"PI = %f%n\", Math.PI); System.out.println(sb.toString());","title":"String formatting"},{"location":"1.11.format/#format-specifiers","text":"Here are the most common conversion specifiers supported in Java: %d: decimal integer (includes byte, short, int, long anb bigint) %f: floating point (includes float and double) %c: unicode character %s: String %n: line separator","title":"Format Specifiers"},{"location":"1.11.format/#argument-index","text":"An argument index is specified as a number ending with a \u201c$\u201d after the \u201c%\u201d and selects the specified argument in the argument list. System.out.printf(\"%2$s\",\"Hello\",\"world\",\"!\"); //prints \"world\" System.out.printf(\"%4$2s %3$2s %2$2s %1$2s\", \"a\", \"b\", \"c\", \"d\") //prints \"d c b a\"","title":"Argument Index"},{"location":"1.11.format/#examples","text":"String.format(\"%d\", 15); //prints: 15 String.format(\"%20d\", 15); //right justify text: 15 String.format(\"%-20d\", 15); //left justify text: 15 String.format(\"%020d\", 15); //prints: 0000000000000000015 System.out.printf(\"%3$20s %1$10s %2$10s\\n\", \"Hora\", \"Minut\",\"Nom\"); //prints: Nom Hora Minut More info","title":"Examples"},{"location":"1.12.string/","text":"The String type String is a reference type consisting of characters. Remember, it's not a primitive type. It is one of the most widely used types in Java. Here is an example of a string: \"Hello, Java\". This string is a sequence of 11 characters, including one space. This type has some features: immutable type: it's impossible to change a character in a string; it has methods for getting individual characters and substrings; characters can be accessed by indexes, the first character has the index 0, the last one - the length of the string - 1. Creating strings A string literal is surrounded by a pair of double quotes, for instance: String simpleString = \"It is a simple string\"; // a simple string System.out.println(simpleString); // it prints \"It is a simple string\" String anotherString = \"This is\\nanother\\nstring\"; // a string with escape sequences System.out.println(anotherString); // it prints the result is several lines A string can represent a long character sequence (text). A string can have one or zero characters. String strangeText = \"aaaaaaaaaaaassssssssssss gggggggggggggggggggg ddddddddddd qqqqqq ffff\"; String emptyString = \"\"; String s = \"s\"; // a string consisting of one character A string can be null. It means no any value assigned. String nullString = null; // it is null Another way to create a variable of type String is used the keyword new. String str = new String(\"my-string\"); // it creates an object and assigns it to the variable Get the length and characters of a string Any string has two useful methods: length() returns the number of characters in the string; charAt(index) returns a character by its index; Here is an example: String s = \"Hi, all\"; int len = s.length(); // the len is 7 char theFirstChar = s.charAt(0); // 'H' has the index 0 char theFifthChar = s.charAt(4); // 'a' has the index 4 char theLastChar = s.charAt(s.length() - 1); // 'l' has the index 6 Note, you can easily get a character of a string by the index, but you can't change characters because strings are immutable in Java. Useful methods of strings The standard library of Java provides a lot of useful methods for processing strings: isEmpty() returns true if the string is empty, otherwise - false; toUpperCase() returns a new string in uppercase; toLowerCase() returns a new string in lowercase; startsWith(prefix) returns true if the string is start with the given string prefix, otherwise - false; contains(...) returns true if the string contains the given string or character; substring(beginIndex, endIndex) returns a substring of the string in the range: beginIndex, endIndex - 1; replace(old, new) returns a new string obtained by replacing all occurrences of old with new that can be chars or strings. See the following example to better understand these methods: String text = \"The simple text string\"; boolean empty = text.isEmpty(); // false String textInUpperCase = text.toUpperCase(); // \"THE SIMPLE TEXT STRING\" boolean startsWith = simple.startsWith(\"THE\"); // true /* replace all whitespaces with empty strings */ String noWhitespaces = text.replace(\" \", \"\"); // \"THESIMPLETEXTSTRING\" Listed methods can take different arguments. See Java API for details: https://docs.oracle.com/javase/8/docs/api/java/lang/String.html Exceptions when processing strings When working with strings, there can be several exceptions. NullPointerException. If a string is null and you call a method of the string, it throws NullPointerException. String s = null; int length = s.length(); // it throws NullPointerException StringIndexOutOfBoundsException. If you try to access a non-existing character by an index then this exception occurs. String s = \"ab\"; char c = s.charAt(2); // it throws StringIndexOutOfBoundsException Be careful. Concatenating strings Two string can be concatenated using the \"+\" operator or the concat method. In both cases, the result is the same. String firstName = \"John\"; String lastName = \"Smith\"; // concatenation using the \"+\" operator String fullName1 = firstName + \" \" + lastName; // \"John Smith\" // concatenation using the concat method String fullName2 = firstName.concat(\" \").concat(lastName); // \"John Smith\" When we concatenate two strings a new string is created (because strings are immutable). Important: in the general case str1 + str2 is not the same as str2 + str1 because the concatenation is not a commutative operation. Appending values to a string It's possible to add values of different types to a string. The value will be automatically converted to a string. See an example below. String str = \"str\" + 10 + false; // the result is \"str10false\" In the example above, the order of execution is: \"str\" + 10 => \"str10\" \"str10\" + false = \"str10false\" Let's see more complex example: String shortString = \"str\"; long number = 100; String result1 = shortString + number + 50; // the result is \"str10050\" String result2 = number + 50 + shortString; // what is the result2? The result2 is 150str, because, first, we calculate a sum of number and 50 and then concat it with str. The order of operations is important. How to compare strings correctly? The strings are a reference type you shouldn't compare them using \"==\" or \"!=\" operators. In these case, only addresses will be compared, but not actual values. A string has two convenient methods for comparing it with other strings: equals(other) and equalsIgnoreCase(other). See an example below. String first = \"first\"; String second = \"second\"; String anotherFirst = \"first\"; String secondInUpperCase = \"SECOND\"; System.out.println(first.equals(second)); // false, the strings have different values System.out.println(first.equals(anotherFirst)); // true, the strings have the same value System.out.println(second.equals(secondInUpperCase)); // false, the strings have different cases System.out.println(second.equalsIgnoreCase(secondInUpperCase)); // true, it ignores cases Do not forget the rules when comparing strings. Regular Expressions What is a RegEx? A regular expression (shortened as regex) is a sequence of characters that define a search pattern . Usually such patterns are used by string-searching algorithms for \"find\" or \"find and replace\" operations on strings, or for input validation. Regular expressions are used in search engines, search and replace dialogs of word processors and text editors, in text processing utilities such as sed and AWK and in lexical analysis. Many programming languages provide regex capabilities either built-in or via libraries. Symbols Symbols for charsets: Samples RegEx in Java Here is a simple java regex example that uses a regular expression to check if a text contains the substring http:// : String text = \"This is the text to be searched \" + \"for occurrences of the http:// pattern.\"; String regex = \".*http://.*\"; boolean matches = Pattern.matches(regex, text); System.out.println(\"matches = \" + matches); The text variable contains the text to be checked with the regular expression. The pattern variable contains the regular expression as a String. The regular expression matches all texts which contains one or more characters (. ) followed by the text http:// followed by one or more characters (. ). The third line uses the Pattern.matches() static method to check if the regular expression (pattern) matches the text. If the regular expression matches the text, then Pattern.matches() returns true. If the regular expression does not match the text Pattern.matches() returns false. The example does not actually check if the found http:// string is part of a valid URL, with domain name and suffix (.com, .net etc.). The regular expression just checks for an occurrence of the string http://. Useful Links [Great game online about RegEx] (https://regexcrossword.com/) [Tester Online] (https://regex101.com/) [Cheat sheet] (http://www.rexegg.com/regex-quickstart.html) Cheat sheet in Java More examples","title":"Strings"},{"location":"1.12.string/#the-string-type","text":"String is a reference type consisting of characters. Remember, it's not a primitive type. It is one of the most widely used types in Java. Here is an example of a string: \"Hello, Java\". This string is a sequence of 11 characters, including one space. This type has some features: immutable type: it's impossible to change a character in a string; it has methods for getting individual characters and substrings; characters can be accessed by indexes, the first character has the index 0, the last one - the length of the string - 1.","title":"The String type"},{"location":"1.12.string/#creating-strings","text":"A string literal is surrounded by a pair of double quotes, for instance: String simpleString = \"It is a simple string\"; // a simple string System.out.println(simpleString); // it prints \"It is a simple string\" String anotherString = \"This is\\nanother\\nstring\"; // a string with escape sequences System.out.println(anotherString); // it prints the result is several lines A string can represent a long character sequence (text). A string can have one or zero characters. String strangeText = \"aaaaaaaaaaaassssssssssss gggggggggggggggggggg ddddddddddd qqqqqq ffff\"; String emptyString = \"\"; String s = \"s\"; // a string consisting of one character A string can be null. It means no any value assigned. String nullString = null; // it is null Another way to create a variable of type String is used the keyword new. String str = new String(\"my-string\"); // it creates an object and assigns it to the variable","title":"Creating strings"},{"location":"1.12.string/#get-the-length-and-characters-of-a-string","text":"Any string has two useful methods: length() returns the number of characters in the string; charAt(index) returns a character by its index; Here is an example: String s = \"Hi, all\"; int len = s.length(); // the len is 7 char theFirstChar = s.charAt(0); // 'H' has the index 0 char theFifthChar = s.charAt(4); // 'a' has the index 4 char theLastChar = s.charAt(s.length() - 1); // 'l' has the index 6 Note, you can easily get a character of a string by the index, but you can't change characters because strings are immutable in Java.","title":"Get the length and characters of a string"},{"location":"1.12.string/#useful-methods-of-strings","text":"The standard library of Java provides a lot of useful methods for processing strings: isEmpty() returns true if the string is empty, otherwise - false; toUpperCase() returns a new string in uppercase; toLowerCase() returns a new string in lowercase; startsWith(prefix) returns true if the string is start with the given string prefix, otherwise - false; contains(...) returns true if the string contains the given string or character; substring(beginIndex, endIndex) returns a substring of the string in the range: beginIndex, endIndex - 1; replace(old, new) returns a new string obtained by replacing all occurrences of old with new that can be chars or strings. See the following example to better understand these methods: String text = \"The simple text string\"; boolean empty = text.isEmpty(); // false String textInUpperCase = text.toUpperCase(); // \"THE SIMPLE TEXT STRING\" boolean startsWith = simple.startsWith(\"THE\"); // true /* replace all whitespaces with empty strings */ String noWhitespaces = text.replace(\" \", \"\"); // \"THESIMPLETEXTSTRING\" Listed methods can take different arguments. See Java API for details: https://docs.oracle.com/javase/8/docs/api/java/lang/String.html","title":"Useful methods of strings"},{"location":"1.12.string/#exceptions-when-processing-strings","text":"When working with strings, there can be several exceptions. NullPointerException. If a string is null and you call a method of the string, it throws NullPointerException. String s = null; int length = s.length(); // it throws NullPointerException StringIndexOutOfBoundsException. If you try to access a non-existing character by an index then this exception occurs. String s = \"ab\"; char c = s.charAt(2); // it throws StringIndexOutOfBoundsException Be careful.","title":"Exceptions when processing strings"},{"location":"1.12.string/#concatenating-strings","text":"Two string can be concatenated using the \"+\" operator or the concat method. In both cases, the result is the same. String firstName = \"John\"; String lastName = \"Smith\"; // concatenation using the \"+\" operator String fullName1 = firstName + \" \" + lastName; // \"John Smith\" // concatenation using the concat method String fullName2 = firstName.concat(\" \").concat(lastName); // \"John Smith\" When we concatenate two strings a new string is created (because strings are immutable). Important: in the general case str1 + str2 is not the same as str2 + str1 because the concatenation is not a commutative operation.","title":"Concatenating strings"},{"location":"1.12.string/#appending-values-to-a-string","text":"It's possible to add values of different types to a string. The value will be automatically converted to a string. See an example below. String str = \"str\" + 10 + false; // the result is \"str10false\" In the example above, the order of execution is: \"str\" + 10 => \"str10\" \"str10\" + false = \"str10false\" Let's see more complex example: String shortString = \"str\"; long number = 100; String result1 = shortString + number + 50; // the result is \"str10050\" String result2 = number + 50 + shortString; // what is the result2? The result2 is 150str, because, first, we calculate a sum of number and 50 and then concat it with str. The order of operations is important.","title":"Appending values to a string"},{"location":"1.12.string/#how-to-compare-strings-correctly","text":"The strings are a reference type you shouldn't compare them using \"==\" or \"!=\" operators. In these case, only addresses will be compared, but not actual values. A string has two convenient methods for comparing it with other strings: equals(other) and equalsIgnoreCase(other). See an example below. String first = \"first\"; String second = \"second\"; String anotherFirst = \"first\"; String secondInUpperCase = \"SECOND\"; System.out.println(first.equals(second)); // false, the strings have different values System.out.println(first.equals(anotherFirst)); // true, the strings have the same value System.out.println(second.equals(secondInUpperCase)); // false, the strings have different cases System.out.println(second.equalsIgnoreCase(secondInUpperCase)); // true, it ignores cases Do not forget the rules when comparing strings.","title":"How to compare strings correctly?"},{"location":"1.12.string/#regular-expressions","text":"","title":"Regular Expressions"},{"location":"1.12.string/#what-is-a-regex","text":"A regular expression (shortened as regex) is a sequence of characters that define a search pattern . Usually such patterns are used by string-searching algorithms for \"find\" or \"find and replace\" operations on strings, or for input validation. Regular expressions are used in search engines, search and replace dialogs of word processors and text editors, in text processing utilities such as sed and AWK and in lexical analysis. Many programming languages provide regex capabilities either built-in or via libraries.","title":"What is a RegEx?"},{"location":"1.12.string/#symbols","text":"Symbols for charsets:","title":"Symbols"},{"location":"1.12.string/#samples","text":"","title":"Samples"},{"location":"1.12.string/#regex-in-java","text":"Here is a simple java regex example that uses a regular expression to check if a text contains the substring http:// : String text = \"This is the text to be searched \" + \"for occurrences of the http:// pattern.\"; String regex = \".*http://.*\"; boolean matches = Pattern.matches(regex, text); System.out.println(\"matches = \" + matches); The text variable contains the text to be checked with the regular expression. The pattern variable contains the regular expression as a String. The regular expression matches all texts which contains one or more characters (. ) followed by the text http:// followed by one or more characters (. ). The third line uses the Pattern.matches() static method to check if the regular expression (pattern) matches the text. If the regular expression matches the text, then Pattern.matches() returns true. If the regular expression does not match the text Pattern.matches() returns false. The example does not actually check if the found http:// string is part of a valid URL, with domain name and suffix (.com, .net etc.). The regular expression just checks for an occurrence of the string http://.","title":"RegEx in Java"},{"location":"1.12.string/#useful-links","text":"[Great game online about RegEx] (https://regexcrossword.com/) [Tester Online] (https://regex101.com/) [Cheat sheet] (http://www.rexegg.com/regex-quickstart.html) Cheat sheet in Java More examples","title":"Useful Links"},{"location":"1.13.dates/","text":"The most commonly used classes are LocalDate, LocalTime and LocalDateTime. As their names indicate, they represent the local Date/Time from the context of the observer. LocalDate The LocalDate represents a date in ISO format (yyyy-MM-dd) without time. It can be used to store dates like birthdays and paydays. An instance of current date can be created from the system clock as below: LocalDate localDate = LocalDate.now(); The LocalDate representing a specific day, month and year can be obtained using the \u201cof\u201d method or by using the \u201cparse\u201d method. For example the below code snippets represents the LocalDate for 20 February 2020: LocalDate.of(2020, 02, 20); LocalDate.parse(\"2020-02-20\"); Useful methods are: plusDays(int):add extra days to a date minus(int): substract some days to a date isLeapYear(): check if the year is leap or not (t/f) getDayOfWeek() getDayOfMonth() isBefore(date2)/isAfter(date2): checks if a date is before or after another date until(date2, unit): compare to dates, where unit can be ChronoUnit.DAYS, ChronoUnit.MONTHS, ChronoUnit.YEARS The class Period also have a method called between that allows to compare to dates: int yearsBetween = Period.between(dataNaix, avui).getYears(); LocalTime The LocalTime represents time without a date. Similar to LocalDate an instance of LocalTime can be created from system clock or by using \u201cparse\u201d and \u201cof\u201d method. Quick look at some of the commonly used APIs below. LocalTime now = LocalTime.now(); LocalTime sixThirty = LocalTime.parse(\"06:30\"); LocalTime sixThirty2 = LocalTime.of(6, 32); Useful methods: long hoursBetween = ChronoUnit.HOURS.between(now1, now2); long minutesBetween = ChronoUnit.MINUTES.between(now1, now2); System.out.println(hoursBetween); System.out.println(minutesBetween); LocalDateTime The LocalDateTime is used to represent a combination of date and time. LocalDateTime.now(); LocalDateTime.of(2020, Month.FEBRUARY, 20, 06, 30); LocalDateTime.parse(\"2020-02-20T06:30:00\"); DateTimeFormatter The DateTimeFormatter provides various standard formatting options: y = year (yy or yyyy) M = month (M for numbers without zero, MM for 2numbers and MMMM for the name of month) d = day in month (dd) h = hour (0-12) (hh) H = hour (0-23) (HH) m = minute in hour (mm) s = seconds (ss) S = milliseconds (SSS) E = day of week (EEEE) Custom patterns can be provided to format method as well, like below, which would return a LocalDate as 2020/01/25 LocalDateTime localDateTime = LocalDateTime.of(2020, Month.JANUARY, 25, 6, 30); String printedLocalDateTime = localDateTime.format(DateTimeFormatter.ofPattern(\"yyyy/MM/dd\")); System.out.println(printedLocalDateTime); DateTimeFormatter formatter = DateTimeFormatter.BASIC_ISO_DATE; String formattedDate = formatter.format(LocalDate.now()); System.out.println(formattedDate); Examples LocalDate avui = LocalDate.now(); String avuiFormatat = avui.format(DateTimeFormatter.ofPattern(\"dd-MM-yyyy\")); System.out.println(avuiFormatat); LocalDate dema = avui.plusDays(1); boolean esTraspas = LocalDate.now().isLeapYear(); LocalDateTime ara = LocalDateTime.now(); String araFormatat = ara.format(DateTimeFormatter.ofPattern(\"dd-MM-yyyy HH:mm\")); System.out.println(araFormatat); LocalDate celebracio = LocalDate.of(2020, 02, 20); int diesEntremig = Period.between(celebracio, avui).getDays(); LocalDateTime festa = LocalDateTime.of(2017, Month.FEBRUARY,3,6,30,40,50000); System.out.println(festa); More info: Link1 Link2 Link3","title":"Dates"},{"location":"1.13.dates/#localdate","text":"The LocalDate represents a date in ISO format (yyyy-MM-dd) without time. It can be used to store dates like birthdays and paydays. An instance of current date can be created from the system clock as below: LocalDate localDate = LocalDate.now(); The LocalDate representing a specific day, month and year can be obtained using the \u201cof\u201d method or by using the \u201cparse\u201d method. For example the below code snippets represents the LocalDate for 20 February 2020: LocalDate.of(2020, 02, 20); LocalDate.parse(\"2020-02-20\"); Useful methods are: plusDays(int):add extra days to a date minus(int): substract some days to a date isLeapYear(): check if the year is leap or not (t/f) getDayOfWeek() getDayOfMonth() isBefore(date2)/isAfter(date2): checks if a date is before or after another date until(date2, unit): compare to dates, where unit can be ChronoUnit.DAYS, ChronoUnit.MONTHS, ChronoUnit.YEARS The class Period also have a method called between that allows to compare to dates: int yearsBetween = Period.between(dataNaix, avui).getYears();","title":"LocalDate"},{"location":"1.13.dates/#localtime","text":"The LocalTime represents time without a date. Similar to LocalDate an instance of LocalTime can be created from system clock or by using \u201cparse\u201d and \u201cof\u201d method. Quick look at some of the commonly used APIs below. LocalTime now = LocalTime.now(); LocalTime sixThirty = LocalTime.parse(\"06:30\"); LocalTime sixThirty2 = LocalTime.of(6, 32); Useful methods: long hoursBetween = ChronoUnit.HOURS.between(now1, now2); long minutesBetween = ChronoUnit.MINUTES.between(now1, now2); System.out.println(hoursBetween); System.out.println(minutesBetween);","title":"LocalTime"},{"location":"1.13.dates/#localdatetime","text":"The LocalDateTime is used to represent a combination of date and time. LocalDateTime.now(); LocalDateTime.of(2020, Month.FEBRUARY, 20, 06, 30); LocalDateTime.parse(\"2020-02-20T06:30:00\");","title":"LocalDateTime"},{"location":"1.13.dates/#datetimeformatter","text":"The DateTimeFormatter provides various standard formatting options: y = year (yy or yyyy) M = month (M for numbers without zero, MM for 2numbers and MMMM for the name of month) d = day in month (dd) h = hour (0-12) (hh) H = hour (0-23) (HH) m = minute in hour (mm) s = seconds (ss) S = milliseconds (SSS) E = day of week (EEEE) Custom patterns can be provided to format method as well, like below, which would return a LocalDate as 2020/01/25 LocalDateTime localDateTime = LocalDateTime.of(2020, Month.JANUARY, 25, 6, 30); String printedLocalDateTime = localDateTime.format(DateTimeFormatter.ofPattern(\"yyyy/MM/dd\")); System.out.println(printedLocalDateTime); DateTimeFormatter formatter = DateTimeFormatter.BASIC_ISO_DATE; String formattedDate = formatter.format(LocalDate.now()); System.out.println(formattedDate);","title":"DateTimeFormatter"},{"location":"1.13.dates/#examples","text":"LocalDate avui = LocalDate.now(); String avuiFormatat = avui.format(DateTimeFormatter.ofPattern(\"dd-MM-yyyy\")); System.out.println(avuiFormatat); LocalDate dema = avui.plusDays(1); boolean esTraspas = LocalDate.now().isLeapYear(); LocalDateTime ara = LocalDateTime.now(); String araFormatat = ara.format(DateTimeFormatter.ofPattern(\"dd-MM-yyyy HH:mm\")); System.out.println(araFormatat); LocalDate celebracio = LocalDate.of(2020, 02, 20); int diesEntremig = Period.between(celebracio, avui).getDays(); LocalDateTime festa = LocalDateTime.of(2017, Month.FEBRUARY,3,6,30,40,50000); System.out.println(festa); More info: Link1 Link2 Link3","title":"Examples"},{"location":"1.2.comments/","text":"Comments in Java code Inside a Java program, you can write special text which will be ignored by the java compiler - known as comments. They allow you to exclude code from the compilation process (disable it) or clarify a piece of code to yourself or other developers. The Java programming language supports three kinds of comments. End-of-line comments The java compiler ignores any text from // to the end of the line: class Task { public static void main(String[] args) { // The line below will be ignored // System.out.println(\"Hello, World\"); // It prints the string \"Hello, Java\" System.out.println(\"Hello, Java\"); // You can write a comment here } } Multi-line comments The compiler ignores any text from / and the nearest /. It can be used as multiple and single-line comments: class Task { public static void main(String[] args) { /* This is a single-line comment */ /* This is a example of a multi-line comment */ } } You can use comments inside other comments: class Task { public static void main(String[] args) { /* int a = 1; // set a to 1 int b = 2; // set b to 2 int c = a + b; // calculate a + b */ } } Java documentation comments The compiler ignores any text from /* to / just like it ignores multi-line comments. This kind of comments can be used to automatically generate documentation about your source code using the javadoc tool. Usually, these comments are placed above declarations of classes, interfaces, methods, and so on. Also, in this case, some special labels such as @param, @return and others are used for controlling the tool. class Task { /** * The main method accepts an array of string arguments * * @param args from the command line */ public static void main(String[] args) { // do nothing } }","title":"Comments"},{"location":"1.2.comments/#comments-in-java-code","text":"Inside a Java program, you can write special text which will be ignored by the java compiler - known as comments. They allow you to exclude code from the compilation process (disable it) or clarify a piece of code to yourself or other developers. The Java programming language supports three kinds of comments.","title":"Comments in Java code"},{"location":"1.2.comments/#end-of-line-comments","text":"The java compiler ignores any text from // to the end of the line: class Task { public static void main(String[] args) { // The line below will be ignored // System.out.println(\"Hello, World\"); // It prints the string \"Hello, Java\" System.out.println(\"Hello, Java\"); // You can write a comment here } }","title":"End-of-line comments"},{"location":"1.2.comments/#multi-line-comments","text":"The compiler ignores any text from / and the nearest /. It can be used as multiple and single-line comments: class Task { public static void main(String[] args) { /* This is a single-line comment */ /* This is a example of a multi-line comment */ } } You can use comments inside other comments: class Task { public static void main(String[] args) { /* int a = 1; // set a to 1 int b = 2; // set b to 2 int c = a + b; // calculate a + b */ } }","title":"Multi-line comments"},{"location":"1.2.comments/#java-documentation-comments","text":"The compiler ignores any text from /* to / just like it ignores multi-line comments. This kind of comments can be used to automatically generate documentation about your source code using the javadoc tool. Usually, these comments are placed above declarations of classes, interfaces, methods, and so on. Also, in this case, some special labels such as @param, @return and others are used for controlling the tool. class Task { /** * The main method accepts an array of string arguments * * @param args from the command line */ public static void main(String[] args) { // do nothing } }","title":"Java documentation comments"},{"location":"1.3.mainmethod/","text":"Main method The declaration of the main method Java is primarily an object-oriented language. It means a Java program can be considered to be a collection of objects that communicate via calling each other's methods. A typical Java program includes a lot of classes, interfaces, objects, and other concepts from object-oriented programming. Even the simplest \"procedural-style\" program should have at least one class and the main method inside it to start the program. The main method is the entry point for any applications. Ever since Java 7 there has been no other way to start an application without this method (excluding the case when you start your application inside a special container for applications but it is not considered in this course). Let's see an example of the simplest application that prints the text \"Hello, Java\" in the standard output: class Task { public static void main(String[] args) { System.out.println(\"Hello, Java\"); } } Here is a class named Task. The class contains the main method for starting the program. It is important to mention that a class containing the main method can have any name, but the main method should always have the same name. Let's take a closer look at the declaration of the main method: public static void main(String[] args) The keyword public indicates that the method can be invoked from everywhere The keyword static indicates the method can be invoked without creating an instance of the class The keyword void indicates the method doesn't return any value The array variable args contains arguments entered at the command line if there are no arguments then the array is empty As you can see, even the simplest Java application contains a lot of concepts. All of them will be studied in the next few topics which relate to methods and object-oriented programming. For now you just need to understand how to write and run a simple Java program with the main method. Invalid declarations of the main method If the main method has an invalid declaration, two cases are possible: your program cannot be compiled your program is successfully compiled but can't be started Your program cannot be compiled It is the case when the main method declaration breaks the syntax of Java. Example: no returning value (even void) class Task { public static main(String[] args) { System.out.println(\"Hello, Java\"); } } Example: a mistake in the keyword (pubic instead of public) class Task { pubic static void main(String[] args) { System.out.println(\"Hello, Java\"); } } A program can be compiled but cannot be run It is the case when the main method has a correct declaration as a regular method but it doesn't satisfy the specific requirement of the main method. Examples: should be String[] args class Task { public static main(String args) { System.out.println(\"Hello, Java\"); } } Example: there is no keyword static class Task { public void main(String[] args) { System.out.println(\"Hello, Java\"); } } In both cases, an error happens at runtime. Conclusion So, the main method is the entry point of any Java programs. It has a very specific syntax which you need to remember. IDE tips & tricks Mistakes are an essential part of successful learning. They can also be very annoying and drain your motivation. The IDE helps you with code errors, by alerting you to the most common ones and suggesting solutions. Take a look at the code example from the \u201cInvalid declarations of the main method\u201d above. The red squiggly line under the code means there\u2019s something wrong. Put the cursor on the highlighted code to see what the issue is: You can use the red bulb or press Alt + Enter to see a list of suggested fixes. Note the red icon at the top right. It shows you that there are some errors in the file. Hover over the red stripe to see the list of errors. Click on it to navigate to the line with the error and fix it: When everything is fixed, there is a green check icon in the right top corner:","title":"Main method"},{"location":"1.3.mainmethod/#main-method","text":"","title":"Main method"},{"location":"1.3.mainmethod/#the-declaration-of-the-main-method","text":"Java is primarily an object-oriented language. It means a Java program can be considered to be a collection of objects that communicate via calling each other's methods. A typical Java program includes a lot of classes, interfaces, objects, and other concepts from object-oriented programming. Even the simplest \"procedural-style\" program should have at least one class and the main method inside it to start the program. The main method is the entry point for any applications. Ever since Java 7 there has been no other way to start an application without this method (excluding the case when you start your application inside a special container for applications but it is not considered in this course). Let's see an example of the simplest application that prints the text \"Hello, Java\" in the standard output: class Task { public static void main(String[] args) { System.out.println(\"Hello, Java\"); } } Here is a class named Task. The class contains the main method for starting the program. It is important to mention that a class containing the main method can have any name, but the main method should always have the same name. Let's take a closer look at the declaration of the main method: public static void main(String[] args) The keyword public indicates that the method can be invoked from everywhere The keyword static indicates the method can be invoked without creating an instance of the class The keyword void indicates the method doesn't return any value The array variable args contains arguments entered at the command line if there are no arguments then the array is empty As you can see, even the simplest Java application contains a lot of concepts. All of them will be studied in the next few topics which relate to methods and object-oriented programming. For now you just need to understand how to write and run a simple Java program with the main method.","title":"The declaration of the main method"},{"location":"1.3.mainmethod/#invalid-declarations-of-the-main-method","text":"If the main method has an invalid declaration, two cases are possible: your program cannot be compiled your program is successfully compiled but can't be started","title":"Invalid declarations of the main method"},{"location":"1.3.mainmethod/#your-program-cannot-be-compiled","text":"It is the case when the main method declaration breaks the syntax of Java. Example: no returning value (even void) class Task { public static main(String[] args) { System.out.println(\"Hello, Java\"); } } Example: a mistake in the keyword (pubic instead of public) class Task { pubic static void main(String[] args) { System.out.println(\"Hello, Java\"); } } A program can be compiled but cannot be run It is the case when the main method has a correct declaration as a regular method but it doesn't satisfy the specific requirement of the main method. Examples: should be String[] args class Task { public static main(String args) { System.out.println(\"Hello, Java\"); } } Example: there is no keyword static class Task { public void main(String[] args) { System.out.println(\"Hello, Java\"); } } In both cases, an error happens at runtime.","title":"Your program cannot be compiled"},{"location":"1.3.mainmethod/#conclusion","text":"So, the main method is the entry point of any Java programs. It has a very specific syntax which you need to remember.","title":"Conclusion"},{"location":"1.3.mainmethod/#ide-tips-tricks","text":"Mistakes are an essential part of successful learning. They can also be very annoying and drain your motivation. The IDE helps you with code errors, by alerting you to the most common ones and suggesting solutions. Take a look at the code example from the \u201cInvalid declarations of the main method\u201d above. The red squiggly line under the code means there\u2019s something wrong. Put the cursor on the highlighted code to see what the issue is: You can use the red bulb or press Alt + Enter to see a list of suggested fixes. Note the red icon at the top right. It shows you that there are some errors in the file. Hover over the red stripe to see the list of errors. Click on it to navigate to the line with the error and fix it: When everything is fixed, there is a green check icon in the right top corner:","title":"IDE tips &amp; tricks"},{"location":"1.4.variables/","text":"Variables A variable is a named storage for a value. It has a name (identifier) and a type. The name identifies a variable in some context. It's possible to read and change the value of a variable by its name. The general form for declaring variables is the following: DataType variableName; The type (data type) of a variable determines which values can be stored in the variable and the possible operations you can perform on them. Data types Java is a statically typed programming language, which means that every variable and every expression has a type that is known at the compile time. All data types are separated into two groups: primitive types and references types. A primitive type variable stores a simple value (such as a number or character). Java has eight primitive data types. They can be divided into four groups: integer numbers: byte, short, int, long (for example, 83 is an integer number) floating-point numbers: float, double (for example, 3.1415 is a floating point number) logical type: boolean (true or false) characters: char (for example, 'a', '3') The most used primitive types are int, long, boolean, char and double. primitiveDataTypes A reference type variable stores an address in memory where the data is located. The data can be made up as a complex structure that includes other data types as their parts. We will often use the reference type String. It represents a sequence of characters like \"abc\" or \"Hello, Java\". Let's declare a variable named number of the type int: int number; Here is a variable named text of the type String: String text; Sizes and ranges of primitive types Integer types store numbers such as 10, 15, -14. The size of the values that can be stored depends on the integer type that we choose. The range of values is calculated as \u2212(2n\u22121) -2^(n-1) to 2^(n\u22121)\u22121, where n is the number of bits. The range includes 0 as well. byte: the size is 8 bits (1 byte), the range is from -128 to +127 short: the size is 16 bits (2 bytes), the range is from -32768 to +32767 int: the size is 32 bits (4 bytes), the range is from \u2212(2^31) to +(2^31)-1 long: the size is 64 bits (8 bytes), the range is from \u2212(2^63) to +(2^63)-1 Floating-point types represent numbers with a fractional part. float: the size is 32 bits (4 bytes), the range is from 3.4e\u2212038 to 3.4e+038 (approximately, 6-7 significant decimal digits) double: the size is 64 bits (8 bytes), the range is from 1.7e\u2212308 to 1.7e+308 (approximately, 14-16 significant decimal digits) The character type (char) stores the character constant in the memory. The size is 16 bits (2 bytes). The range is from 0 to 65536 (unsigned). The boolean type can store only two values: true or false. It represents only one bit of information, but its size is not something that's precisely defined. So, remember Java has 8 primitive types. The most used are int, long, boolean, char, and double. The assignment operator Java has a special operator denoted as =. It assigns a value to a variable. In this case, the variable has to be declared already: variableName = value; It is also possible to declare and initialize a variable in one line: DataType variableName = value; class Task { public static void main(String[] args) { // put your code here int one = 1; // declares an integer variable \"one\" and assigns the value 1 to it int two; // declares an integer variable \"two\" two = 2; // assign the value 2 to the variable \"two\" int three = 3, four = 4; // declares two integer variables and assigns values to them } } To read the value of a variable you should write its name. For example, let's print the variables: System.out.println(one); // prints 1 System.out.println(two); // prints 2 System.out.println(three); // prints 3 System.out.println(four); // prints 4 In the following example, the variable five is declared and initialized with the value of another variable: int five = four; // read the value of the variable \"four\" and assign it to the variable \"five\"; Here are some more variables: char ch = 'A'; // declare a character variable named \"ch\" and assign 'A' to it String str = \"Hello, Java\"; // declare a string variable named \"str\" and assign text to it double pi = 3.1415; // declare a double variable named \"pi\" and assign 3.1415 to it For more details about variables go here : https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html Rules for naming variables Java has some rules for naming variables: names are case-sensitive a name can include Unicode letters, digits, and two special characters ($, _) a name can't start with a digit a name must not be a keyword (class, static, and int are illegal names) You cannot break these rules, otherwise, your program will not compile. Here are some legal names of variables: number, $ident, bigValue, _val, abc, k, var And here are some illegal ones: @ab, 1c, !ab, class Ever since Java 9, the single character _ is an illegal way to name a variable, but _a and __ are legal names. Naming conventions for variables Also, there are naming conventions for naming variables: if a variable name has a single word it should be in lowercase (for instance: number, val) if a variable name includes multiple words it should be in lowerCamelCase, i.e. the first word should be in lowercase and each word after the first has its first letter written in uppercase (for instance: numberOfCoins) variable names should not start with _ or $ characters, even though both are allowed These conventions are not required, but it is strongly recommended to follow them. They make your code more readable for yourself and other Java programmers. Input and output in Java code There are several ways to read values from the standard input. The first way is to use java.util.Scanner. Let's read two integer numbers from the standard input, add them together and write the result in the standard output: import java.util.Scanner; public class Task { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int a = scanner.nextInt(); // it reads an integer value from the standard input int b = scanner.nextInt(); // it reads another integer value from the standard input System.out.println(a + b); // it writes the result of a + b in the standard output } } Another common way to read integer numbers is to use java.io.BufferedReader. Let's read two integer numbers, add them together and write the result in the standard output again: import java.io.BufferedReader; import java.io.InputStreamReader; import java.io.IOException; public class Task { public static void main(String[] args) throws IOException { // the object for reading BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); // it takes a string and splits it by whitespaces String[] values = reader.readLine().split(\"\\\\s+\"); int a = Integer.parseInt(values[0]); // It converts the first value to integer int b = Integer.parseInt(values[1]); // It converts the second value to integer System.out.println(a + b); } } IDE tips & tricks Code autocompletion can help you to find the right variable. Once declared, a variable is added to the autocompletion list. Just start typing or simply press Ctrl + Space to get a list of all the options.","title":"Variables and Types"},{"location":"1.4.variables/#variables","text":"A variable is a named storage for a value. It has a name (identifier) and a type. The name identifies a variable in some context. It's possible to read and change the value of a variable by its name. The general form for declaring variables is the following: DataType variableName; The type (data type) of a variable determines which values can be stored in the variable and the possible operations you can perform on them.","title":"Variables"},{"location":"1.4.variables/#data-types","text":"Java is a statically typed programming language, which means that every variable and every expression has a type that is known at the compile time. All data types are separated into two groups: primitive types and references types. A primitive type variable stores a simple value (such as a number or character). Java has eight primitive data types. They can be divided into four groups: integer numbers: byte, short, int, long (for example, 83 is an integer number) floating-point numbers: float, double (for example, 3.1415 is a floating point number) logical type: boolean (true or false) characters: char (for example, 'a', '3') The most used primitive types are int, long, boolean, char and double. primitiveDataTypes A reference type variable stores an address in memory where the data is located. The data can be made up as a complex structure that includes other data types as their parts. We will often use the reference type String. It represents a sequence of characters like \"abc\" or \"Hello, Java\". Let's declare a variable named number of the type int: int number; Here is a variable named text of the type String: String text;","title":"Data types"},{"location":"1.4.variables/#sizes-and-ranges-of-primitive-types","text":"Integer types store numbers such as 10, 15, -14. The size of the values that can be stored depends on the integer type that we choose. The range of values is calculated as \u2212(2n\u22121) -2^(n-1) to 2^(n\u22121)\u22121, where n is the number of bits. The range includes 0 as well. byte: the size is 8 bits (1 byte), the range is from -128 to +127 short: the size is 16 bits (2 bytes), the range is from -32768 to +32767 int: the size is 32 bits (4 bytes), the range is from \u2212(2^31) to +(2^31)-1 long: the size is 64 bits (8 bytes), the range is from \u2212(2^63) to +(2^63)-1 Floating-point types represent numbers with a fractional part. float: the size is 32 bits (4 bytes), the range is from 3.4e\u2212038 to 3.4e+038 (approximately, 6-7 significant decimal digits) double: the size is 64 bits (8 bytes), the range is from 1.7e\u2212308 to 1.7e+308 (approximately, 14-16 significant decimal digits) The character type (char) stores the character constant in the memory. The size is 16 bits (2 bytes). The range is from 0 to 65536 (unsigned). The boolean type can store only two values: true or false. It represents only one bit of information, but its size is not something that's precisely defined. So, remember Java has 8 primitive types. The most used are int, long, boolean, char, and double. The assignment operator Java has a special operator denoted as =. It assigns a value to a variable. In this case, the variable has to be declared already: variableName = value; It is also possible to declare and initialize a variable in one line: DataType variableName = value; class Task { public static void main(String[] args) { // put your code here int one = 1; // declares an integer variable \"one\" and assigns the value 1 to it int two; // declares an integer variable \"two\" two = 2; // assign the value 2 to the variable \"two\" int three = 3, four = 4; // declares two integer variables and assigns values to them } } To read the value of a variable you should write its name. For example, let's print the variables: System.out.println(one); // prints 1 System.out.println(two); // prints 2 System.out.println(three); // prints 3 System.out.println(four); // prints 4 In the following example, the variable five is declared and initialized with the value of another variable: int five = four; // read the value of the variable \"four\" and assign it to the variable \"five\"; Here are some more variables: char ch = 'A'; // declare a character variable named \"ch\" and assign 'A' to it String str = \"Hello, Java\"; // declare a string variable named \"str\" and assign text to it double pi = 3.1415; // declare a double variable named \"pi\" and assign 3.1415 to it For more details about variables go here : https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html","title":"Sizes and ranges of primitive types"},{"location":"1.4.variables/#rules-for-naming-variables","text":"Java has some rules for naming variables: names are case-sensitive a name can include Unicode letters, digits, and two special characters ($, _) a name can't start with a digit a name must not be a keyword (class, static, and int are illegal names) You cannot break these rules, otherwise, your program will not compile. Here are some legal names of variables: number, $ident, bigValue, _val, abc, k, var And here are some illegal ones: @ab, 1c, !ab, class Ever since Java 9, the single character _ is an illegal way to name a variable, but _a and __ are legal names.","title":"Rules for naming variables"},{"location":"1.4.variables/#naming-conventions-for-variables","text":"Also, there are naming conventions for naming variables: if a variable name has a single word it should be in lowercase (for instance: number, val) if a variable name includes multiple words it should be in lowerCamelCase, i.e. the first word should be in lowercase and each word after the first has its first letter written in uppercase (for instance: numberOfCoins) variable names should not start with _ or $ characters, even though both are allowed These conventions are not required, but it is strongly recommended to follow them. They make your code more readable for yourself and other Java programmers.","title":"Naming conventions for variables"},{"location":"1.4.variables/#input-and-output-in-java-code","text":"There are several ways to read values from the standard input. The first way is to use java.util.Scanner. Let's read two integer numbers from the standard input, add them together and write the result in the standard output: import java.util.Scanner; public class Task { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int a = scanner.nextInt(); // it reads an integer value from the standard input int b = scanner.nextInt(); // it reads another integer value from the standard input System.out.println(a + b); // it writes the result of a + b in the standard output } } Another common way to read integer numbers is to use java.io.BufferedReader. Let's read two integer numbers, add them together and write the result in the standard output again: import java.io.BufferedReader; import java.io.InputStreamReader; import java.io.IOException; public class Task { public static void main(String[] args) throws IOException { // the object for reading BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); // it takes a string and splits it by whitespaces String[] values = reader.readLine().split(\"\\\\s+\"); int a = Integer.parseInt(values[0]); // It converts the first value to integer int b = Integer.parseInt(values[1]); // It converts the second value to integer System.out.println(a + b); } }","title":"Input and output in Java code"},{"location":"1.4.variables/#ide-tips-tricks","text":"Code autocompletion can help you to find the right variable. Once declared, a variable is added to the autocompletion list. Just start typing or simply press Ctrl + Space to get a list of all the options.","title":"IDE tips &amp; tricks"},{"location":"1.5.integer/","text":"Integer An overview of primitive types for integer numbers There are four ways to represent integer numbers in Java: byte, short, int, and long. These types differ by their sizes and ranges: byte: the size is 8 bits (1 byte), the range is from -128 to +127 short: the size is 16 bits (2 bytes), the range is from -32768 to +32767 int: the size is 32 bits (4 bytes), the range is from \u2212(2^31) to +(2^31)-1 long: the size is 64 bits (8 bytes), the range is from \u2212(2^63) to +(2^63)-1 The most widely used integer types are int and long. The largest one is long and smallest one is byte. Let's declare and initialize several variables of different integer types: class Task { public static void main(String[] args) { int decimalNumber = 500; // a decimal number, it consists of digits 0-9 int hexNumber = 0xFF; // a hexadecimal number, it consists of digits 0-9 and letters A-F int binaryNumber = 0b10001; // a binary number, it consists of digits 0 and 1 int octalNumber = 0335; // an octal number, it consists of digits 0-7 long longNumber = 33L; // L or l - is a literal for longs long bigNumber = 100_000_000_000L; // _ is the underscore character } } If an integer value ends with the letter L or l it is the type long, otherwise it is the type int. It's recommended to use the uppercase letter L because the lowercase letter l is similar to the digit 1. The default value for all integer types is 0 (zero): int intZero; // it's equal to 0; long longZero; // it's equal to 0L; ```` To know the max and min values for these types you should write the following code: ```java int minInt = Integer.MIN_VALUE; // The min value of int type int maxInt = Integer.MAX_VALUE; // The max value of int type long minLong = Long.MIN_VALUE; // The min value of long type long maxLong = Long.MAX_VALUE; // The max value of long type Now it's time to learn about arithmetic operations for integer types. Binary operators The Java programming language provides operators for performing addition, subtraction, multiplication, division (integer) and remainder with two integer numbers (byte, short, int, long). The first three operators should be absolutely clear, but the last two may need additional explanation. The operator / returns the integer part of division two numbers, a fractional part is discarded. The operator % returns the remainder of two numbers. For instance 10 % 3 is 1 because 10 divided by 3 leaves a remainder of 1. See the following example: int a = 6; int b = 2; int sum = a + b; // addition, the result is 8 int diff = a - b; // subtraction, the result is 4 int mult = a * b; // multiplication, the result is 12 int intDiv = a / b; // integer division, the result is 3 int remainder = a % b; // remainder, the result is 0 All five operators can be performed for negative numbers as well. Let's consider another example with integer division and remainder: int a = 15; Int b = 6; // a is 15, b is 6 int intDiv = a / b; // integer division, the result is 2 int rem = a % b; // remainder, the result is 3 int negRem = -21 % 4; // the result is -1 because -21 divided by 4 leaves a remainder of -1 Be careful with the dividing numbers by zero (0). It throws a runtime exception. int divResult = 5 / 0; // throws ArithmeticException int remResult = 5 % 0; // also throws ArithmeticException Unary operators Also there are several unary operators: unary plus, unary minus, increment (prefix and postfix), decrement (prefix and postfix). The unary plus indicates a positive value. It's an optional operator. The unary minus negates a value or an expression: int a = +4; // unary plus indicates the positive value (it's an optional operator) int b = -a; // unary minus negates the value 4, the result is -4 b = -b; // negate the value again, the result is 4 The increment operator adds 1 to the variable's value. The decrement operator subtracts 1 from the variable's value. Both operators exist in two forms: prefix and postfix. The difference between prefix and postfix forms is the order of execution. In the prefix form first of all the value is changed and then it is assigned to another variable. In the postfix form at first the value is assigned to another variable and then it is changed: int a = 5; // a is 5 int b = ++a; // prefix increment: b is 6, a is 6 int c = b++; // postfix increment: c is 6, b is 7 int d = c--; // postfix decrement: d is 6, c is 5 ```` ##The different forms of the assignment operator In Java the assignment operator (\"=\") has several additional forms: +=, *=, /=, %= and so one: ```java int a = 2, b = 3, c = 4; a += b; // the same as a = a + b, the result is 5 c *= b; // the same as c = c * b, the result is 12 Arithmetic and assignment operators precedence Operators have different priorities in expressions. These priorities define the operator's precedence (the order of execution). Below, the studied operators are listed according to precedence order (from the highest to the lowest): unary: +, -, ++, -- multiplicative: *, /, % additive: +, - assignment: =, +=, -=, *=, /= To change the order of execution, you can enclose the expression in parentheses like in mathematics: ```java int a = 3 + 4 * 5; // the result is 23 int b = (3 + 4) * 5; // the result is 35 int c = 1 + (2 * (3 + (4 * (5 + 6)))); // 11 -> 44 -> 47 -> 94 -> 95 ```` Note: All listed rules are also valid for other integer types: byte, short, long.","title":"Integer"},{"location":"1.5.integer/#integer","text":"An overview of primitive types for integer numbers There are four ways to represent integer numbers in Java: byte, short, int, and long. These types differ by their sizes and ranges: byte: the size is 8 bits (1 byte), the range is from -128 to +127 short: the size is 16 bits (2 bytes), the range is from -32768 to +32767 int: the size is 32 bits (4 bytes), the range is from \u2212(2^31) to +(2^31)-1 long: the size is 64 bits (8 bytes), the range is from \u2212(2^63) to +(2^63)-1 The most widely used integer types are int and long. The largest one is long and smallest one is byte. Let's declare and initialize several variables of different integer types: class Task { public static void main(String[] args) { int decimalNumber = 500; // a decimal number, it consists of digits 0-9 int hexNumber = 0xFF; // a hexadecimal number, it consists of digits 0-9 and letters A-F int binaryNumber = 0b10001; // a binary number, it consists of digits 0 and 1 int octalNumber = 0335; // an octal number, it consists of digits 0-7 long longNumber = 33L; // L or l - is a literal for longs long bigNumber = 100_000_000_000L; // _ is the underscore character } } If an integer value ends with the letter L or l it is the type long, otherwise it is the type int. It's recommended to use the uppercase letter L because the lowercase letter l is similar to the digit 1. The default value for all integer types is 0 (zero): int intZero; // it's equal to 0; long longZero; // it's equal to 0L; ```` To know the max and min values for these types you should write the following code: ```java int minInt = Integer.MIN_VALUE; // The min value of int type int maxInt = Integer.MAX_VALUE; // The max value of int type long minLong = Long.MIN_VALUE; // The min value of long type long maxLong = Long.MAX_VALUE; // The max value of long type Now it's time to learn about arithmetic operations for integer types.","title":"Integer"},{"location":"1.5.integer/#binary-operators","text":"The Java programming language provides operators for performing addition, subtraction, multiplication, division (integer) and remainder with two integer numbers (byte, short, int, long). The first three operators should be absolutely clear, but the last two may need additional explanation. The operator / returns the integer part of division two numbers, a fractional part is discarded. The operator % returns the remainder of two numbers. For instance 10 % 3 is 1 because 10 divided by 3 leaves a remainder of 1. See the following example: int a = 6; int b = 2; int sum = a + b; // addition, the result is 8 int diff = a - b; // subtraction, the result is 4 int mult = a * b; // multiplication, the result is 12 int intDiv = a / b; // integer division, the result is 3 int remainder = a % b; // remainder, the result is 0 All five operators can be performed for negative numbers as well. Let's consider another example with integer division and remainder: int a = 15; Int b = 6; // a is 15, b is 6 int intDiv = a / b; // integer division, the result is 2 int rem = a % b; // remainder, the result is 3 int negRem = -21 % 4; // the result is -1 because -21 divided by 4 leaves a remainder of -1 Be careful with the dividing numbers by zero (0). It throws a runtime exception. int divResult = 5 / 0; // throws ArithmeticException int remResult = 5 % 0; // also throws ArithmeticException","title":"Binary operators"},{"location":"1.5.integer/#unary-operators","text":"Also there are several unary operators: unary plus, unary minus, increment (prefix and postfix), decrement (prefix and postfix). The unary plus indicates a positive value. It's an optional operator. The unary minus negates a value or an expression: int a = +4; // unary plus indicates the positive value (it's an optional operator) int b = -a; // unary minus negates the value 4, the result is -4 b = -b; // negate the value again, the result is 4 The increment operator adds 1 to the variable's value. The decrement operator subtracts 1 from the variable's value. Both operators exist in two forms: prefix and postfix. The difference between prefix and postfix forms is the order of execution. In the prefix form first of all the value is changed and then it is assigned to another variable. In the postfix form at first the value is assigned to another variable and then it is changed: int a = 5; // a is 5 int b = ++a; // prefix increment: b is 6, a is 6 int c = b++; // postfix increment: c is 6, b is 7 int d = c--; // postfix decrement: d is 6, c is 5 ```` ##The different forms of the assignment operator In Java the assignment operator (\"=\") has several additional forms: +=, *=, /=, %= and so one: ```java int a = 2, b = 3, c = 4; a += b; // the same as a = a + b, the result is 5 c *= b; // the same as c = c * b, the result is 12","title":"Unary operators"},{"location":"1.5.integer/#arithmetic-and-assignment-operators-precedence","text":"Operators have different priorities in expressions. These priorities define the operator's precedence (the order of execution). Below, the studied operators are listed according to precedence order (from the highest to the lowest): unary: +, -, ++, -- multiplicative: *, /, % additive: +, - assignment: =, +=, -=, *=, /= To change the order of execution, you can enclose the expression in parentheses like in mathematics: ```java int a = 3 + 4 * 5; // the result is 23 int b = (3 + 4) * 5; // the result is 35 int c = 1 + (2 * (3 + (4 * (5 + 6)))); // 11 -> 44 -> 47 -> 94 -> 95 ```` Note: All listed rules are also valid for other integer types: byte, short, long.","title":"Arithmetic and assignment operators precedence"},{"location":"1.6.boolean/","text":"The boolean type The boolean is a primitive data type that has only two possible values: false or true. The default value for this type is false. boolean t = true; // t is true boolean f = false; // f is false boolean defaultValue; // defaultValue is false Note: Remember, you cannot assign an integer value to a boolean variable. In Java, 0 is not equal to false. Logical operators There are four logical operators NOT, AND, OR and XOR which allow us to build logical expressions. The NOT operator is a unary operator that reverses the boolean value. It is written as !. boolean f = false; // f is false boolean t = !f; // t is true The AND operator is a binary operator that returns true if both operands are true, otherwise, it is false. The operator can be written as && and &. boolean b1 = false && false; // false boolean b2 = false && true; // false boolean b3 = true && false; // false boolean b4 = true && true; // true The OR operator is a binary operator that returns true if at least one operand is true, otherwise, it returns false. The operator can be written as ||and |. boolean b1 = false || false; // false boolean b2 = false || true; // true boolean b3 = true || false; // true boolean b4 = true || true; // true The XOR (exclusive OR) operator is a binary operator that returns true if boolean operands have different values, otherwise, it is false. The operator is written as ^ and can be used Instead of the relation operator != (NOT EQUAL TO). boolean b1 = false ^ false; // false boolean b2 = false ^ true; // true boolean b3 = true ^ false; // true boolean b4 = true ^ true; // false Short-circuit operators The AND and OR operators have two forms: AND ( &, &&), OR ( |, ||). There are some differences: * the & and | operators are also used as bitwise operators for integer types; * the && and || operator perform Conditional-AND and Conditional-OR operations on two boolean expressions. These operators are called \"short-circuit\" operators, which means that the second operand is evaluated only when it is needed (when the first argument doesn't suffice to determine the value of the expression). In the following example, the second operand a>5 will not be evaluated because the result is determined by the first operand (a==10 is false): int a = 20; boolean result = (a == 10) && (a > 5); // the second expressions can't be evaluated The precedence of logical operators Below the logical operations are sorted in order of their priority in expressions: ! - NOT & - AND ^ - XOR | - OR && - conditional AND || - conditional OR So, the following statement is true: boolean b = true && !false; // true, because !false is evaluated first Relational operators A relational operator tests or defines some kind of relation between two operands. Java has six relational operators: == (equal to) != (not equal to) (greater than) = (greater than or equal to) < (less than) <= (less than or equal to) The result of applying a relational operator to operands is the boolean type (true or false). Operators == and != can be applied to operands of any primitive types, but operators >, >=, <, <= cannot be applied to boolean operands. In expressions, the relational operators have a lower priority than arithmetic operators. Comparing integer numbers Relational operators allow you to easily compare two integer numbers: int num1 = 4; int num2 = 2; boolean b1 = num1 == num2; // false boolean b2 = num1 > num2; // true boolean b3 = 500 != 500; // false boolean b4 = 300 <= 300; // true We can compare longs, bytes, and shorts in the same way. In the following example, first, the sums will be calculated and then will be compared using the operator >: long number = 1000; boolean result = number + 10 > number + 9; // 1010 > 1009 is true Comparing characters Characters are ordered, it's possible to compare two characters by their code values using any relational operations. Characters can be compared ( ==, !=, <, <=, >, >=) by their codes: System.out.println('a' < 'b'); // prints \"true\" System.out.println('a' == 'a'); // prints \"true\" System.out.println('e' < 'E'); // prints \"false\" Comparing floating-point numbers During the operation with floating-point numbers, errors can be accumulated. Do not use == or != when comparing floating-point numbers in Java. Instead, if you'd like to compare two floating-point values a and b, use the standard way: Math.abs(a - b) < eps It means the absolute value of the difference is less than a certain epsilon. Here is an example why it's important: double val = 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1; // 0.99999... System.out.println(val == 1.0); // it prints \"false\" System.out.println(Math.abs(val - 1.0) < 1e-6); // it prints \"true\" Joining relational operations using logical operators In Java, you cannot write an expression like this: a <= b <= c Instead, you should join two boolean expressions using logical operators like || and &&. For example, we'd like to check the expression: 100 < number < 200 In Java we should write something like this: number > 100 && number < 200 Also, we can write with parentheses: (number > 100) && (number < 200) But parentheses are not necessary here because relational operators have the higher priority than logical operators. Here is a more general example of variables: ```java //the code checks that the value of number belongs to a range int number = ... // it has a value int low = 100, high = 200; // borders boolean inRange = number > low && number < high; // join two expressions using AND \u222b``` So, logical operators allow you to join a sequence of relational operations into one expression.","title":"Boolean"},{"location":"1.6.boolean/#the-boolean-type","text":"The boolean is a primitive data type that has only two possible values: false or true. The default value for this type is false. boolean t = true; // t is true boolean f = false; // f is false boolean defaultValue; // defaultValue is false Note: Remember, you cannot assign an integer value to a boolean variable. In Java, 0 is not equal to false.","title":"The boolean type"},{"location":"1.6.boolean/#logical-operators","text":"There are four logical operators NOT, AND, OR and XOR which allow us to build logical expressions. The NOT operator is a unary operator that reverses the boolean value. It is written as !. boolean f = false; // f is false boolean t = !f; // t is true The AND operator is a binary operator that returns true if both operands are true, otherwise, it is false. The operator can be written as && and &. boolean b1 = false && false; // false boolean b2 = false && true; // false boolean b3 = true && false; // false boolean b4 = true && true; // true The OR operator is a binary operator that returns true if at least one operand is true, otherwise, it returns false. The operator can be written as ||and |. boolean b1 = false || false; // false boolean b2 = false || true; // true boolean b3 = true || false; // true boolean b4 = true || true; // true The XOR (exclusive OR) operator is a binary operator that returns true if boolean operands have different values, otherwise, it is false. The operator is written as ^ and can be used Instead of the relation operator != (NOT EQUAL TO). boolean b1 = false ^ false; // false boolean b2 = false ^ true; // true boolean b3 = true ^ false; // true boolean b4 = true ^ true; // false","title":"Logical operators"},{"location":"1.6.boolean/#short-circuit-operators","text":"The AND and OR operators have two forms: AND ( &, &&), OR ( |, ||). There are some differences: * the & and | operators are also used as bitwise operators for integer types; * the && and || operator perform Conditional-AND and Conditional-OR operations on two boolean expressions. These operators are called \"short-circuit\" operators, which means that the second operand is evaluated only when it is needed (when the first argument doesn't suffice to determine the value of the expression). In the following example, the second operand a>5 will not be evaluated because the result is determined by the first operand (a==10 is false): int a = 20; boolean result = (a == 10) && (a > 5); // the second expressions can't be evaluated","title":"Short-circuit operators"},{"location":"1.6.boolean/#the-precedence-of-logical-operators","text":"Below the logical operations are sorted in order of their priority in expressions: ! - NOT & - AND ^ - XOR | - OR && - conditional AND || - conditional OR So, the following statement is true: boolean b = true && !false; // true, because !false is evaluated first","title":"The precedence of logical operators"},{"location":"1.6.boolean/#relational-operators","text":"A relational operator tests or defines some kind of relation between two operands. Java has six relational operators: == (equal to) != (not equal to) (greater than) = (greater than or equal to) < (less than) <= (less than or equal to) The result of applying a relational operator to operands is the boolean type (true or false). Operators == and != can be applied to operands of any primitive types, but operators >, >=, <, <= cannot be applied to boolean operands. In expressions, the relational operators have a lower priority than arithmetic operators.","title":"Relational operators"},{"location":"1.6.boolean/#comparing-integer-numbers","text":"Relational operators allow you to easily compare two integer numbers: int num1 = 4; int num2 = 2; boolean b1 = num1 == num2; // false boolean b2 = num1 > num2; // true boolean b3 = 500 != 500; // false boolean b4 = 300 <= 300; // true We can compare longs, bytes, and shorts in the same way. In the following example, first, the sums will be calculated and then will be compared using the operator >: long number = 1000; boolean result = number + 10 > number + 9; // 1010 > 1009 is true","title":"Comparing integer numbers"},{"location":"1.6.boolean/#comparing-characters","text":"Characters are ordered, it's possible to compare two characters by their code values using any relational operations. Characters can be compared ( ==, !=, <, <=, >, >=) by their codes: System.out.println('a' < 'b'); // prints \"true\" System.out.println('a' == 'a'); // prints \"true\" System.out.println('e' < 'E'); // prints \"false\"","title":"Comparing characters"},{"location":"1.6.boolean/#comparing-floating-point-numbers","text":"During the operation with floating-point numbers, errors can be accumulated. Do not use == or != when comparing floating-point numbers in Java. Instead, if you'd like to compare two floating-point values a and b, use the standard way: Math.abs(a - b) < eps It means the absolute value of the difference is less than a certain epsilon. Here is an example why it's important: double val = 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1; // 0.99999... System.out.println(val == 1.0); // it prints \"false\" System.out.println(Math.abs(val - 1.0) < 1e-6); // it prints \"true\"","title":"Comparing floating-point numbers"},{"location":"1.6.boolean/#joining-relational-operations-using-logical-operators","text":"In Java, you cannot write an expression like this: a <= b <= c Instead, you should join two boolean expressions using logical operators like || and &&. For example, we'd like to check the expression: 100 < number < 200 In Java we should write something like this: number > 100 && number < 200 Also, we can write with parentheses: (number > 100) && (number < 200) But parentheses are not necessary here because relational operators have the higher priority than logical operators. Here is a more general example of variables: ```java //the code checks that the value of number belongs to a range int number = ... // it has a value int low = 100, high = 200; // borders boolean inRange = number > low && number < high; // join two expressions using AND \u222b``` So, logical operators allow you to join a sequence of relational operations into one expression.","title":"Joining relational operations using logical operators"},{"location":"1.7.floatingpoint/","text":"Single and double precision floating-point numbers There are two primitive floating point types: single-precision float (32 bits) and double-precision double (64 bits). Let's declare and initialize some variables of these types: double zero = 0.0; double e = 2.71828; // or 2.71828d double eps = 5e-3; // 5 * 10^(-3) = 0.0005 float pi = 3.1415f; // the literal f is always needed float negValue = -0.15f; // the negative value These types can store only a limited number of significant decimal digits (~6-7 for float and ~14-16 for double): float f = 0.888888888888888888f; // a value with a lot of decimal digits System.out.println(f); // it prints 0.8888889 The following code lets you know the size, the min and the max value of the double type: System.out.println(Double.SIZE); // 64 bits System.out.println(Double.MIN_VALUE); // 4.9E-324 System.out.println(Double.MAX_VALUE); // 1.7976931348623157E308 Arithmetic operations It's possible to perform all arithmetic operations with double and float numbers: addition + subtraction - multiplication * integer division / remainder % System.out.println(3.4 + 6.1); // prints 9.5 System.out.println(1.1 * 2.0); // prints 2.2 We can even increment and decrement the numbers. But be careful, the operations with floating-point numbers can produce an inaccurate result: System.out.println(3.3 / 3); // prints 1.0999999999999999 Errors can accumulate during computation: double val = 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1; System.out.println(val); // it prints 0.9999999999999999","title":"Floating point"},{"location":"1.7.floatingpoint/#single-and-double-precision-floating-point-numbers","text":"There are two primitive floating point types: single-precision float (32 bits) and double-precision double (64 bits). Let's declare and initialize some variables of these types: double zero = 0.0; double e = 2.71828; // or 2.71828d double eps = 5e-3; // 5 * 10^(-3) = 0.0005 float pi = 3.1415f; // the literal f is always needed float negValue = -0.15f; // the negative value These types can store only a limited number of significant decimal digits (~6-7 for float and ~14-16 for double): float f = 0.888888888888888888f; // a value with a lot of decimal digits System.out.println(f); // it prints 0.8888889 The following code lets you know the size, the min and the max value of the double type: System.out.println(Double.SIZE); // 64 bits System.out.println(Double.MIN_VALUE); // 4.9E-324 System.out.println(Double.MAX_VALUE); // 1.7976931348623157E308","title":"Single and double precision floating-point numbers"},{"location":"1.7.floatingpoint/#arithmetic-operations","text":"It's possible to perform all arithmetic operations with double and float numbers: addition + subtraction - multiplication * integer division / remainder % System.out.println(3.4 + 6.1); // prints 9.5 System.out.println(1.1 * 2.0); // prints 2.2 We can even increment and decrement the numbers. But be careful, the operations with floating-point numbers can produce an inaccurate result: System.out.println(3.3 / 3); // prints 1.0999999999999999 Errors can accumulate during computation: double val = 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1; System.out.println(val); // it prints 0.9999999999999999","title":"Arithmetic operations"},{"location":"1.8.math/","text":"The standard class Math The standard class Math, contains a lot of methods for performing basic numeric operations including exponential, modulus, trigonometric functions, finding the max/min of two numbers and so on. The most common methods are listed below: Math.abs(...) returns the absolute value of its argument Math.sqrt(...) returns the square root of its argument Math.cbrt(...) returns the cube root of its argument Math.pow(..., ...) returns the value of the first argument raised to the power of the second argument Math.min(..., ...) returns the smaller value of two arguments Math.max(..., ...) returns the greater value of two arguments Math.toRadians(...) converts an angle measured in degrees to an angle measured in radians (approximately) Math.sin(...) returns the trigonometric sin of the given angle in radians Math.cos(...) returns the trigonometric cos of the given angle in radians Math.random() returns a double value with a positive sign, greater than or equal to 0.0 and less than 1.0 Math.floor(...) returns the largest double value that is less than or equal to its argument and is equal to an integer Math.ceil(...) returns the smallest double value that is greater than or equal to its argument and is equal to an integer More useful methods see in docs: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html Also this class has two useful constants: Math.PI - the ratio of the circumference of a circle to its diameter Math.E - the base of the natural logarithm Examples Let's look at examples of all the considered methods: int abs = Math.abs(-10); // abs is 10 double dabs = Math.abs(-10.33); // dabs is 10.33 double sqrt = Math.sqrt(2); // sqrt is 1.4142... double cbrt = Math.cbrt(27.0); // cbrt is 3.0 double square = Math.pow(5, 2); // the square of 5 is 25.0 double cube = Math.pow(2, 3); // the cube of 2 is 8.0 int min = Math.min(11, 81); // min is 11 int max = Math.max(20, 30); // max is 30 double grad = Math.toRadians(30); // grad is 0.5235... double pi = Math.PI; // pi is 3.1415... double sin = Math.sin(pi / 2); // sin is 1.0 double cos = Math.cos(pi); // cos90 is -1.0 double random = Math.random(); // a random value >= 0.0 and < 1.0 double floor = Math.floor(3.78); // floor is 3.0 double ceil = Math.ceil(4.15); // ceil is 5.0 The length of the hypotenuse Let's assume we have a right-angled triangle (one angle is 90 degree). We know the lengths of the two sides: a = 3 and b = 4. To calculate the length of hypotenuse we can write the following code: double a = 3, b = 4; double c = Math.hypot(a, b); // c is 5.0 As you can see, the Math class has a lot of methods for performing numeric calculations.","title":"Math"},{"location":"1.8.math/#the-standard-class-math","text":"The standard class Math, contains a lot of methods for performing basic numeric operations including exponential, modulus, trigonometric functions, finding the max/min of two numbers and so on. The most common methods are listed below: Math.abs(...) returns the absolute value of its argument Math.sqrt(...) returns the square root of its argument Math.cbrt(...) returns the cube root of its argument Math.pow(..., ...) returns the value of the first argument raised to the power of the second argument Math.min(..., ...) returns the smaller value of two arguments Math.max(..., ...) returns the greater value of two arguments Math.toRadians(...) converts an angle measured in degrees to an angle measured in radians (approximately) Math.sin(...) returns the trigonometric sin of the given angle in radians Math.cos(...) returns the trigonometric cos of the given angle in radians Math.random() returns a double value with a positive sign, greater than or equal to 0.0 and less than 1.0 Math.floor(...) returns the largest double value that is less than or equal to its argument and is equal to an integer Math.ceil(...) returns the smallest double value that is greater than or equal to its argument and is equal to an integer More useful methods see in docs: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html Also this class has two useful constants: Math.PI - the ratio of the circumference of a circle to its diameter Math.E - the base of the natural logarithm","title":"The standard class Math"},{"location":"1.8.math/#examples","text":"Let's look at examples of all the considered methods: int abs = Math.abs(-10); // abs is 10 double dabs = Math.abs(-10.33); // dabs is 10.33 double sqrt = Math.sqrt(2); // sqrt is 1.4142... double cbrt = Math.cbrt(27.0); // cbrt is 3.0 double square = Math.pow(5, 2); // the square of 5 is 25.0 double cube = Math.pow(2, 3); // the cube of 2 is 8.0 int min = Math.min(11, 81); // min is 11 int max = Math.max(20, 30); // max is 30 double grad = Math.toRadians(30); // grad is 0.5235... double pi = Math.PI; // pi is 3.1415... double sin = Math.sin(pi / 2); // sin is 1.0 double cos = Math.cos(pi); // cos90 is -1.0 double random = Math.random(); // a random value >= 0.0 and < 1.0 double floor = Math.floor(3.78); // floor is 3.0 double ceil = Math.ceil(4.15); // ceil is 5.0","title":"Examples"},{"location":"1.8.math/#the-length-of-the-hypotenuse","text":"Let's assume we have a right-angled triangle (one angle is 90 degree). We know the lengths of the two sides: a = 3 and b = 4. To calculate the length of hypotenuse we can write the following code: double a = 3, b = 4; double c = Math.hypot(a, b); // c is 5.0 As you can see, the Math class has a lot of methods for performing numeric calculations.","title":"The length of the hypotenuse"},{"location":"1.9.character/","text":"Characters Char is a primitive type for storing and processing single 16-bit Unicode characters. A char literal is a single character enclosed in single quote marks like: 'A', 'b', '8'. Some features of this data type: It has a minimum value of \\'u0000'and a maximum value of '\\uffff'; variables of this type can be used as 16-bit unsigned integer numbers in arithmetic operations (the range is [0, 65535]); characters are ordered, it's possible to compare two character values. There are some examples of characters: char a = 'a'; // the 'a' character char b = 'a' + 1; // the 'b' character char d = 'b' + 2; // the 'd' character char ch1 = 101; // the 'e' character char ch2 = '\\u0040'; // the '@' character If you'd like to find the code of a character, see the Unicode table. Remember: char ch1 = '1'; // the character '1' char ch2 = 1; // it's another character from the unicode table, it\u2019s not the same as '1' Escape sequences Some characters are used to control computer devices. They are known as the escape sequences or control sequences. They consists of more than one element, but they are considered as a single character. The most widely used escape sequences: '\\n' is the newline character; '\\t' is the tab character; '\\r' is the carriage return character; '\\' is the backslash character; '\\'' is the single quote mark; '\\\"' is the double quote mark. See the following code example: System.out.print('\\t'); // make a tab System.out.print('a'); // prints 'a' System.out.print('\\n'); // go to the new line System.out.print('c'); // prints 'c' The output: a c Arithmetic operations All five arithmetic operations ( +, -, *, /, %) are admissible for characters. These operations are performed on the codes of the characters: char b = 'a' + 1; // in the unicode table the next after 'a' is 'b' char zero = 48; // '0' char one = '0' + 1; // in the unicode table the next after '0' is '1' char ch = '1' + '2'; // the result is 'c', not '3' because the operation sums codes Methods for processing characters The class Character has some useful methods for processing characters. Some of them are given below: Character.isDigit(char ch) returns true if the given character is a digit ('1', '2', etc), otherwise - false; Character.isLetter(char ch) returns true if the given character is a letter (a', 'A', 'b', etc), otherwise - false; Character.isLetterOrDigit(char ch) returns true if the given character is a letter or a digit, otherwise - false; Character.isWhitespace(char ch) returns true if the given character is the white space, otherwise - false; Character.isUpperCase(char ch) returns true if the given character is an uppercase character, otherwise - false; Character.isLowerCase(char ch) returns true if the given character is an lowercase character, otherwise - false; Character.toUpperCase(char ch) returns the uppercase form of the given character; Character.toLowerCase(char ch) returns the lowercase form of the given character. Let's see an examples for the listed methods: boolean isDigit = Character.isDigit('1'); // true boolean isLetter = Character.isLetter('4'); // false boolean isLetterOfDigit = Character.isLetterOrDigit('E'); // true boolean isUpperCase = Character.isUpperCase('A'); // true boolean isLowerCase = Character.isLowerCase('1'); // false char upperCaseA = Character.toUpperCase('a'); The class contains many other methods, see here","title":"Character"},{"location":"1.9.character/#characters","text":"Char is a primitive type for storing and processing single 16-bit Unicode characters. A char literal is a single character enclosed in single quote marks like: 'A', 'b', '8'. Some features of this data type: It has a minimum value of \\'u0000'and a maximum value of '\\uffff'; variables of this type can be used as 16-bit unsigned integer numbers in arithmetic operations (the range is [0, 65535]); characters are ordered, it's possible to compare two character values. There are some examples of characters: char a = 'a'; // the 'a' character char b = 'a' + 1; // the 'b' character char d = 'b' + 2; // the 'd' character char ch1 = 101; // the 'e' character char ch2 = '\\u0040'; // the '@' character If you'd like to find the code of a character, see the Unicode table. Remember: char ch1 = '1'; // the character '1' char ch2 = 1; // it's another character from the unicode table, it\u2019s not the same as '1'","title":"Characters"},{"location":"1.9.character/#escape-sequences","text":"Some characters are used to control computer devices. They are known as the escape sequences or control sequences. They consists of more than one element, but they are considered as a single character. The most widely used escape sequences: '\\n' is the newline character; '\\t' is the tab character; '\\r' is the carriage return character; '\\' is the backslash character; '\\'' is the single quote mark; '\\\"' is the double quote mark. See the following code example: System.out.print('\\t'); // make a tab System.out.print('a'); // prints 'a' System.out.print('\\n'); // go to the new line System.out.print('c'); // prints 'c' The output: a c","title":"Escape sequences"},{"location":"1.9.character/#arithmetic-operations","text":"All five arithmetic operations ( +, -, *, /, %) are admissible for characters. These operations are performed on the codes of the characters: char b = 'a' + 1; // in the unicode table the next after 'a' is 'b' char zero = 48; // '0' char one = '0' + 1; // in the unicode table the next after '0' is '1' char ch = '1' + '2'; // the result is 'c', not '3' because the operation sums codes","title":"Arithmetic operations"},{"location":"1.9.character/#methods-for-processing-characters","text":"The class Character has some useful methods for processing characters. Some of them are given below: Character.isDigit(char ch) returns true if the given character is a digit ('1', '2', etc), otherwise - false; Character.isLetter(char ch) returns true if the given character is a letter (a', 'A', 'b', etc), otherwise - false; Character.isLetterOrDigit(char ch) returns true if the given character is a letter or a digit, otherwise - false; Character.isWhitespace(char ch) returns true if the given character is the white space, otherwise - false; Character.isUpperCase(char ch) returns true if the given character is an uppercase character, otherwise - false; Character.isLowerCase(char ch) returns true if the given character is an lowercase character, otherwise - false; Character.toUpperCase(char ch) returns the uppercase form of the given character; Character.toLowerCase(char ch) returns the lowercase form of the given character. Let's see an examples for the listed methods: boolean isDigit = Character.isDigit('1'); // true boolean isLetter = Character.isLetter('4'); // false boolean isLetterOfDigit = Character.isLetterOrDigit('E'); // true boolean isUpperCase = Character.isUpperCase('A'); // true boolean isLowerCase = Character.isLowerCase('1'); // false char upperCaseA = Character.toUpperCase('a'); The class contains many other methods, see here","title":"Methods for processing characters"},{"location":"2.1.conditionals/","text":"Conditionals What is a conditional statement? A conditional statement is a construct that allows a program to perform different computations depending on a boolean condition. If the condition is true, the program performs one computation; otherwise, the condition is false and the program performs another computation. The condition can be any boolean expression, for instance: a > b, i - j == 1 and so on. There are three types of conditional statements. We will give examples of all of them. A single if statement The simplest form of the conditional statement is the following: if (condition) { // do something } In this case, if the condition is true, the action inside the code block is executed. Otherwise, the program skips the action. See the following example. int age = ...; // it has a value if (age < 3) { System.out.println(\"This person is too young\"); } In this example, if the age is less than 3, the program prints \"This person is too young\". Otherwise, it does nothing. If-else statement The if statement can also be extended to do something else if the condition is false. if (condition) { // do something } else { // do something else } In the above code, if the condition is \"true\", the first code block is executed. Otherwise, the second code block is executed. In the example below, the program outputs different text depending on the value of num (even or odd). Note that a whole number is even if it can be divided evenly by 2; otherwise, it's odd. int num = ...; // num is assigned some value if (num % 2 == 0) { System.out.println(\"It's an even number\"); } else { System.out.println(\"It's an odd number\"); } For example, if the value of num is 10, the program outputs \"It's an even number\". If the value is 11, it outputs \"It's an odd number\". If-else-if statements The most general form of the if-else statement consists of multiple conditions and else-branches. if (condition0) { // do something } else if (condition1) { // do something else 1 // ... } else if (conditionN) { // do something else N } The following code outputs recommendations as to what type of computer you should buy depending on your budget. long dollars = ...; // your budget if (dollars < 1000) { System.out.println(\"Buy a laptop\"); } else if (dollars < 2000) { System.out.println(\"Buy a personal computer\"); } else if (dollars < 100000) { System.out.println(\"Buy a server\"); } else { System.out.println(\"Buy a data center or a quantum computer\"); } This conditional statement has four branches: dollars < 1000, dollars < 2000, dollars < 100000 and dollars >= 100000. For eample, if the value of dollars is 9000, it prints \"Buy a server\".","title":"Conditionals"},{"location":"2.1.conditionals/#conditionals","text":"","title":"Conditionals"},{"location":"2.1.conditionals/#what-is-a-conditional-statement","text":"A conditional statement is a construct that allows a program to perform different computations depending on a boolean condition. If the condition is true, the program performs one computation; otherwise, the condition is false and the program performs another computation. The condition can be any boolean expression, for instance: a > b, i - j == 1 and so on. There are three types of conditional statements. We will give examples of all of them.","title":"What is a conditional statement?"},{"location":"2.1.conditionals/#a-single-if-statement","text":"The simplest form of the conditional statement is the following: if (condition) { // do something } In this case, if the condition is true, the action inside the code block is executed. Otherwise, the program skips the action. See the following example. int age = ...; // it has a value if (age < 3) { System.out.println(\"This person is too young\"); } In this example, if the age is less than 3, the program prints \"This person is too young\". Otherwise, it does nothing.","title":"A single if statement"},{"location":"2.1.conditionals/#if-else-statement","text":"The if statement can also be extended to do something else if the condition is false. if (condition) { // do something } else { // do something else } In the above code, if the condition is \"true\", the first code block is executed. Otherwise, the second code block is executed. In the example below, the program outputs different text depending on the value of num (even or odd). Note that a whole number is even if it can be divided evenly by 2; otherwise, it's odd. int num = ...; // num is assigned some value if (num % 2 == 0) { System.out.println(\"It's an even number\"); } else { System.out.println(\"It's an odd number\"); } For example, if the value of num is 10, the program outputs \"It's an even number\". If the value is 11, it outputs \"It's an odd number\".","title":"If-else statement"},{"location":"2.1.conditionals/#if-else-if-statements","text":"The most general form of the if-else statement consists of multiple conditions and else-branches. if (condition0) { // do something } else if (condition1) { // do something else 1 // ... } else if (conditionN) { // do something else N } The following code outputs recommendations as to what type of computer you should buy depending on your budget. long dollars = ...; // your budget if (dollars < 1000) { System.out.println(\"Buy a laptop\"); } else if (dollars < 2000) { System.out.println(\"Buy a personal computer\"); } else if (dollars < 100000) { System.out.println(\"Buy a server\"); } else { System.out.println(\"Buy a data center or a quantum computer\"); } This conditional statement has four branches: dollars < 1000, dollars < 2000, dollars < 100000 and dollars >= 100000. For eample, if the value of dollars is 9000, it prints \"Buy a server\".","title":"If-else-if statements"},{"location":"2.2.switch/","text":"Three keywords: switch, case and default The switch statement provides a way to choose between multiple cases based on the value of a single variable. The variable in this statement can be an integer number, character, string, or enumeration. We will study the last two types later. The most general form of the switch statement looks as follows: switch (variable) { case value1: // do something here break; case value2: // do something here break; //... other cases case valueN: // do something here break; default: // do something by default } // next statement The keywords switch and case are always required. The keywords break and default are optional. Cases are evaluated sequentially. If a case is valid and it includes the break keyword, the switch construct is finished and execution passes to the next statement. If a case doesn't include the break keyword, the following case(s) will be evaluated too. The default case is only evaluated if no case matches the variable value. Example Let's consider an example. The following code output the name of some integers or the default string. It has three base cases and one default case. int val = ...; // the variable is assigned some value switch (val) { case 0: System.out.println(\"zero\"); break; case 1: System.out.println(\"one\"); break; case 2: System.out.println(\"two\"); break; default: System.out.println(\"The value is less than zero or greater than two\"); } If val equals 0, the code prints: zero If val is 1, the code prints: one If val is 10, the code prints: The value is less than zero or greater than two If you happen to forget to include break, the compiler will not consider it an error. Suppose we removed it from the second case (case 1) and assigned 1 to val. The program would print: one two. However, missing breaks is not a good practice. Try to avoid it.","title":"Switch-case"},{"location":"2.2.switch/#three-keywords-switch-case-and-default","text":"The switch statement provides a way to choose between multiple cases based on the value of a single variable. The variable in this statement can be an integer number, character, string, or enumeration. We will study the last two types later. The most general form of the switch statement looks as follows: switch (variable) { case value1: // do something here break; case value2: // do something here break; //... other cases case valueN: // do something here break; default: // do something by default } // next statement The keywords switch and case are always required. The keywords break and default are optional. Cases are evaluated sequentially. If a case is valid and it includes the break keyword, the switch construct is finished and execution passes to the next statement. If a case doesn't include the break keyword, the following case(s) will be evaluated too. The default case is only evaluated if no case matches the variable value.","title":"Three keywords: switch, case and default"},{"location":"2.2.switch/#example","text":"Let's consider an example. The following code output the name of some integers or the default string. It has three base cases and one default case. int val = ...; // the variable is assigned some value switch (val) { case 0: System.out.println(\"zero\"); break; case 1: System.out.println(\"one\"); break; case 2: System.out.println(\"two\"); break; default: System.out.println(\"The value is less than zero or greater than two\"); } If val equals 0, the code prints: zero If val is 1, the code prints: one If val is 10, the code prints: The value is less than zero or greater than two If you happen to forget to include break, the compiler will not consider it an error. Suppose we removed it from the second case (case 1) and assigned 1 to val. The program would print: one two. However, missing breaks is not a good practice. Try to avoid it.","title":"Example"},{"location":"3.1.loops-while/","text":"While and do-while loops Java provides several kinds of loops for repeating a block of code while a certain condition is true. In this topic, we will learn about two kinds of loops: while and do-while. The difference between them is the order in which the body is executed and the condition is evaluated. The while loop In a while loop, the condition is tested first. The body is only executed if the condition is true, and then the process repeats. The basic syntax of this loop is the following: while (condition) { // do something in the body } The body of the loop may contain any valid Java statements, including conditional statements and even other loops (nested loops). A loop becomes an infinite loop if the condition is always true. For example: while (true) { // infinite loop } We will talk more about using infinite loops in later topics. Examples while Example 1. The following loop prints consecutive integer numbers until reaching 5. int i = 0; while (i < 5) { System.out.println(i); i++; } The output: 0 1 2 3 4 Example 2. The following code prints the English alphabet in a single line. public class WhileDemo { public static void main(String[] args) { char letter = 'A'; while (letter <= 'Z') { System.out.print(letter); letter++; } } } Here's what's happening: the program takes the first character, 'A', and then repeats:if letter is less than or equal to 'Z', the program goes to the loop body; inside the body, it prints the current value of letter and moves on to the next. The output: ABCDEFGHIJKLMNOPQRSTUVWXYZ Example 3. Loop to calculate the factorial of a number Scanner in = new Scanner(System.in); System.out.println(\"Introdueix un n\u00famero\"); int num = in.nextInt(); int fact = 1; while (num > 0) { fact = fact*num; num--; } System.out.println(\"Factorial = \" + fact); The do-while loop In a do-while loop, the body is executed first and only then is the condition statement tested. Therefore, the body will be always executed at least once. The basic syntax of the loop is the following: do { // do something } while (condition); Examples do-while Example 1. The program below keeps reading integer numbers from standard input and outputting them. If 0 is entered, the program outputs it and stops. public class DoWhileDemo { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int value; do { value = scanner.nextInt(); System.out.println(value); } while (value > 0); } } The input: 1 2 4 0 3 The output: 1 2 4 0 Example 2. Do-while loop to calculate the sum of the first X integers (where X is provided by the user) Scanner in = new Scanner(System.in); int sum = 0; int num; do { System.out.println(\"Introdueix un n\u00famero\"); num = in.nextInt(); sum + = num; } while (num != 0); System.out.println(\"Suma = \" + sum); Note that a do-while loop may become infinite, just like a while loop. Links Explanation DO-WHILE by Chris Bosh Explanation WHILE by Marc Zuckerberg","title":"Loops while&do-while"},{"location":"3.1.loops-while/#while-and-do-while-loops","text":"Java provides several kinds of loops for repeating a block of code while a certain condition is true. In this topic, we will learn about two kinds of loops: while and do-while. The difference between them is the order in which the body is executed and the condition is evaluated.","title":"While and do-while loops"},{"location":"3.1.loops-while/#the-while-loop","text":"In a while loop, the condition is tested first. The body is only executed if the condition is true, and then the process repeats. The basic syntax of this loop is the following: while (condition) { // do something in the body } The body of the loop may contain any valid Java statements, including conditional statements and even other loops (nested loops). A loop becomes an infinite loop if the condition is always true. For example: while (true) { // infinite loop } We will talk more about using infinite loops in later topics.","title":"The while loop"},{"location":"3.1.loops-while/#examples-while","text":"Example 1. The following loop prints consecutive integer numbers until reaching 5. int i = 0; while (i < 5) { System.out.println(i); i++; } The output: 0 1 2 3 4 Example 2. The following code prints the English alphabet in a single line. public class WhileDemo { public static void main(String[] args) { char letter = 'A'; while (letter <= 'Z') { System.out.print(letter); letter++; } } } Here's what's happening: the program takes the first character, 'A', and then repeats:if letter is less than or equal to 'Z', the program goes to the loop body; inside the body, it prints the current value of letter and moves on to the next. The output: ABCDEFGHIJKLMNOPQRSTUVWXYZ Example 3. Loop to calculate the factorial of a number Scanner in = new Scanner(System.in); System.out.println(\"Introdueix un n\u00famero\"); int num = in.nextInt(); int fact = 1; while (num > 0) { fact = fact*num; num--; } System.out.println(\"Factorial = \" + fact);","title":"Examples while"},{"location":"3.1.loops-while/#the-do-while-loop","text":"In a do-while loop, the body is executed first and only then is the condition statement tested. Therefore, the body will be always executed at least once. The basic syntax of the loop is the following: do { // do something } while (condition);","title":"The do-while loop"},{"location":"3.1.loops-while/#examples-do-while","text":"Example 1. The program below keeps reading integer numbers from standard input and outputting them. If 0 is entered, the program outputs it and stops. public class DoWhileDemo { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int value; do { value = scanner.nextInt(); System.out.println(value); } while (value > 0); } } The input: 1 2 4 0 3 The output: 1 2 4 0 Example 2. Do-while loop to calculate the sum of the first X integers (where X is provided by the user) Scanner in = new Scanner(System.in); int sum = 0; int num; do { System.out.println(\"Introdueix un n\u00famero\"); num = in.nextInt(); sum + = num; } while (num != 0); System.out.println(\"Suma = \" + sum); Note that a do-while loop may become infinite, just like a while loop.","title":"Examples do-while"},{"location":"3.1.loops-while/#links","text":"Explanation DO-WHILE by Chris Bosh Explanation WHILE by Marc Zuckerberg","title":"Links"},{"location":"3.2.loops-for/","text":"For loop Sometimes, we need to repeat a block of code a certain number of times. Java provides the for-loop that is very convenient for this purpose. This loop is often used to iterate over a range of values or an array. If the number of iteration or the range borders are known, it is recommended to use the for-loop. If they are unknown the while-loop may be a preferable solution. The base for-loop syntax This loop has the following base syntax: for (initialization; condition; increment/decrement) { // do something } The explanations: * the initialization statement is executed once when the loop begins, usually, here loop variables are initialized; * the condition determines the need for the next iteration; if it's false, the loop terminates; * the increment/decrement expression is invoked after each iteration of the loop; usually, here loop variables are changed. Inside the loop's body, the program can perform any correct java statements. It can even contain other loops. The order of execution for any for-loop is always the same: the initialization statement; 1. if the condition is false then terminate; 2. the body 3. the increment/decrement 4. go to the stage 2 (condition). Examples Example 1. Loop for printing integer numbers from 0 to 9 in the same line. int n = 9; for (int i = 0; i <= n; i++) { System.out.print(i + \" \"); } The code outputs: 0 1 2 3 4 5 6 7 8 9 The variable declared in the initialization expression is visible only inside the loop including the condition, the body and the increment/decrement expression. The integer loop's variables is often called i, j, k or index. Example 2. Sum of integer numbers from 1 to 10 (inclusive) using the for-loop. int startIncl = 1, endExcl = 11; int sum = 0; for (int i = startIncl; i < endExcl; i++) { sum += i; } System.out.println(\"Sum = \" + sum); // it prints \"55\" Example 3. Sum of integers from 1 to maximum (inclusive) using the for-loop. Scanner in = new Scanner(System.in); int max = in.nextInt(); int sum = 0; for (int i= 0; i<max;i++){ sum += i; } System.out.println(\"Sum = \" + sum); Note Sometimes it's needed to declare a variable outside the loop. it's possible as well. int i; for (i = 10; i > 0; i--) { System.out.print(i + \" \"); } Infinite for-loop The initialization statement, the condition, and the increment/decrement expression are optional, the for loop may not have one or all of them. Moreover, it's possible to write an infinite loop: for (;;) { // do something } Nested loops It's possible to nest one for-loop into another for-loop. For instance, the following code prints the multiplication table of numbers from 1 to 9 (inclusive). for (int i = 1; i < 10; i++) { for (int j = 1; j < 10; j++) { System.out.print(i * j + \"\\t\"); } System.out.println(); } It outputs: 1 2 3 4 5 6 7 8 9 2 4 6 8 10 12 14 16 18 3 6 9 12 15 18 21 24 27 4 8 12 16 20 24 28 32 36 5 10 15 20 25 30 35 40 45 6 12 18 24 30 36 42 48 54 7 14 21 28 35 42 49 56 63 8 16 24 32 40 48 56 64 72 9 18 27 36 45 54 63 72 81","title":"For loops"},{"location":"3.2.loops-for/#for-loop","text":"Sometimes, we need to repeat a block of code a certain number of times. Java provides the for-loop that is very convenient for this purpose. This loop is often used to iterate over a range of values or an array. If the number of iteration or the range borders are known, it is recommended to use the for-loop. If they are unknown the while-loop may be a preferable solution.","title":"For loop"},{"location":"3.2.loops-for/#the-base-for-loop-syntax","text":"This loop has the following base syntax: for (initialization; condition; increment/decrement) { // do something } The explanations: * the initialization statement is executed once when the loop begins, usually, here loop variables are initialized; * the condition determines the need for the next iteration; if it's false, the loop terminates; * the increment/decrement expression is invoked after each iteration of the loop; usually, here loop variables are changed. Inside the loop's body, the program can perform any correct java statements. It can even contain other loops. The order of execution for any for-loop is always the same: the initialization statement; 1. if the condition is false then terminate; 2. the body 3. the increment/decrement 4. go to the stage 2 (condition).","title":"The base for-loop syntax"},{"location":"3.2.loops-for/#examples","text":"Example 1. Loop for printing integer numbers from 0 to 9 in the same line. int n = 9; for (int i = 0; i <= n; i++) { System.out.print(i + \" \"); } The code outputs: 0 1 2 3 4 5 6 7 8 9 The variable declared in the initialization expression is visible only inside the loop including the condition, the body and the increment/decrement expression. The integer loop's variables is often called i, j, k or index. Example 2. Sum of integer numbers from 1 to 10 (inclusive) using the for-loop. int startIncl = 1, endExcl = 11; int sum = 0; for (int i = startIncl; i < endExcl; i++) { sum += i; } System.out.println(\"Sum = \" + sum); // it prints \"55\" Example 3. Sum of integers from 1 to maximum (inclusive) using the for-loop. Scanner in = new Scanner(System.in); int max = in.nextInt(); int sum = 0; for (int i= 0; i<max;i++){ sum += i; } System.out.println(\"Sum = \" + sum);","title":"Examples"},{"location":"3.2.loops-for/#note","text":"Sometimes it's needed to declare a variable outside the loop. it's possible as well. int i; for (i = 10; i > 0; i--) { System.out.print(i + \" \"); }","title":"Note"},{"location":"3.2.loops-for/#infinite-for-loop","text":"The initialization statement, the condition, and the increment/decrement expression are optional, the for loop may not have one or all of them. Moreover, it's possible to write an infinite loop: for (;;) { // do something }","title":"Infinite for-loop"},{"location":"3.2.loops-for/#nested-loops","text":"It's possible to nest one for-loop into another for-loop. For instance, the following code prints the multiplication table of numbers from 1 to 9 (inclusive). for (int i = 1; i < 10; i++) { for (int j = 1; j < 10; j++) { System.out.print(i * j + \"\\t\"); } System.out.println(); } It outputs: 1 2 3 4 5 6 7 8 9 2 4 6 8 10 12 14 16 18 3 6 9 12 15 18 21 24 27 4 8 12 16 20 24 28 32 36 5 10 15 20 25 30 35 40 45 6 12 18 24 30 36 42 48 54 7 14 21 28 35 42 49 56 63 8 16 24 32 40 48 56 64 72 9 18 27 36 45 54 63 72 81","title":"Nested loops"},{"location":"3.3.branching/","text":"Branching statements Branching statements are used to change the standard behavior of loops: terminate a loop or skip some iterations. The break statement The break statement has two usages: it terminates the current loop (any kind) of any types (for, while, do-while); it terminates a case in the switch statement; In this topic, we will learn the application of the statement to terminate loops. Here is an example: int i = 10; while(true) { if (i == 0) { break; } i--; } This loop will be successfully stopped, even though the condition is always true. The break statement terminates only the current loop. If this loop is inside another loop, the outer loop won't be stopped. The following code prints a ladder of numbers. for (int i = 0; i < 10; i++) { for (int j = 0; j < 10; j++) { System.out.print(j + \" \"); if (i == j) { break; } } System.out.println(); } The break statement can't stop the outer loop (with variable i) and the code prints: 0 0 1 0 1 2 0 1 2 3 0 1 2 3 4 0 1 2 3 4 5 0 1 2 3 4 5 6 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 8 0 1 2 3 4 5 6 7 8 9 To stop the outer loop we'd like to declare boolean variable stopped and use it as a special flag. boolean stopped = false; for (int i = 0; (i < 10) && !stopped; i++) { for (int j = 0; j < 10; j++) { System.out.print(j + \" \"); if (i == j) { stopped = true; break; } } System.out.println(); } Now, the program output is not the same. Also, another way to stop the outer loop exist - labeled break operator. But it's not very good practice to use it. Google it, if you are interested. The continue statement It causes a loop to skip the current iteration and go to the next one. This statement also can be used inside any kinds of loops. inside the for-loop, the continue cases control to immediately move to the increment/decrement statement; inside the while or do-while loop, control immediately move to the condition. In the following example, the sequences of number are output. Odd numbers are skipped. int n = 10; for (int i = 0; i < n; i++) { if (i % 2 != 0) { continue; } System.out.print(i + \" \"); } The output: 0 2 4 6 8 The continue can't skip the current iteration of the outer loop. Often, we can rewrite our loop without using the continue statement. Here is an example: int n = 10; for (int i = 0; i < n; i++) { if (i % 2 == 0) { System.out.print(i + \" \"); } } The result is the same as shown above but the code became shorter and more readable. Do not abuse branching statements.","title":"Branching"},{"location":"3.3.branching/#branching-statements","text":"Branching statements are used to change the standard behavior of loops: terminate a loop or skip some iterations.","title":"Branching statements"},{"location":"3.3.branching/#the-break-statement","text":"The break statement has two usages: it terminates the current loop (any kind) of any types (for, while, do-while); it terminates a case in the switch statement; In this topic, we will learn the application of the statement to terminate loops. Here is an example: int i = 10; while(true) { if (i == 0) { break; } i--; } This loop will be successfully stopped, even though the condition is always true. The break statement terminates only the current loop. If this loop is inside another loop, the outer loop won't be stopped. The following code prints a ladder of numbers. for (int i = 0; i < 10; i++) { for (int j = 0; j < 10; j++) { System.out.print(j + \" \"); if (i == j) { break; } } System.out.println(); } The break statement can't stop the outer loop (with variable i) and the code prints: 0 0 1 0 1 2 0 1 2 3 0 1 2 3 4 0 1 2 3 4 5 0 1 2 3 4 5 6 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 8 0 1 2 3 4 5 6 7 8 9 To stop the outer loop we'd like to declare boolean variable stopped and use it as a special flag. boolean stopped = false; for (int i = 0; (i < 10) && !stopped; i++) { for (int j = 0; j < 10; j++) { System.out.print(j + \" \"); if (i == j) { stopped = true; break; } } System.out.println(); } Now, the program output is not the same. Also, another way to stop the outer loop exist - labeled break operator. But it's not very good practice to use it. Google it, if you are interested.","title":"The break statement"},{"location":"3.3.branching/#the-continue-statement","text":"It causes a loop to skip the current iteration and go to the next one. This statement also can be used inside any kinds of loops. inside the for-loop, the continue cases control to immediately move to the increment/decrement statement; inside the while or do-while loop, control immediately move to the condition. In the following example, the sequences of number are output. Odd numbers are skipped. int n = 10; for (int i = 0; i < n; i++) { if (i % 2 != 0) { continue; } System.out.print(i + \" \"); } The output: 0 2 4 6 8 The continue can't skip the current iteration of the outer loop. Often, we can rewrite our loop without using the continue statement. Here is an example: int n = 10; for (int i = 0; i < n; i++) { if (i % 2 == 0) { System.out.print(i + \" \"); } } The result is the same as shown above but the code became shorter and more readable. Do not abuse branching statements.","title":"The continue statement"},{"location":"4.1.arrays/","text":"Arrays An array is an ordered collection of elements of the same type. It can store only a fixed number of elements. The length of an array is established when the array is created. Arrays allow you to group and processing similar data together. In the following picture, an array of five floating-point elements is presented. An array of five int elements Some features: an array is a reference type; all elements are stored in the memory sequentially ; each element of an array is accessed by its numerical index, the first element has the index 0; the last element is accessed by the index equal to array size - 1; it's possible to create an array of any types; the maximum size of an array is limited by the Integer.MAX_VALUE; 1st Step: Declaration, instantiation, initialization To create an array filled with useful elements we should: declare a variable of an array type (declaration); create an instance of the array object (instantiation); initialize the array by some values (initialization). Declaration To declare an array we must use two special characters [] after the name of the type of elements in the array: int[] array; // declaration ``` or after the name of an array variable: ```java int array[]; // declaration Creating an array with the specified elements Java provides several ways to create an array. The simplest way to instantiate and initialize an array is to enumerate all its elements: int[] numbers = { 1, 2, 3, 4 }; // an array of 1, 2, 3, 4 But, this way to create an array has some disadvantages: we need to know values and number of elements at the moment of compilation. Another way is to initialize an array using variables: int a = ..., b = ..., c = ...; int[] numbers = { a, b, c }; In this case, we should have all elements at the moment of the array creation. Creating an array using the keyword \"new\" The most general way to create an instance (object) of an array is to use the special keyword new and specify the necessary number of elements: int n = ...; // n is a length of an array int[] numbers = new int[n]; Now, the array has n elements. Each element is equal to 0 (the default value). Next, we should make explicit initialization of elements. It's possible to separate declaration and instantiation in two lines: int[] numbers; numbers = new int[n]; Also, we can write the keyword new and enumerate all elements of an array: float[] floatNumbers; // declaration floatNumbers = new float[] { 1.02f, 0.03f, 4f } // instantiation and initialization Where to place []? Another feature associated with the creating of arrays is the location of characters []. char[] chars1 = new char[n]; // [] after the type char chars2[] = new char[n]; // [] after the variable Often, Java developers use the first way because it signals that an array is a special type. The length of an array To obtain the length of an existing array we should write arrayName.length. It returns the length of the array. Here is an example: int[] array = { 1, 2, 3, 4 }; // an array of numbers int length = array.length; // number of elements of the array System.out.println(length); // 4 2nd Step: Access Specific element by index The values of elements of an array can be changed. To set (get) a value to (from) array the index is used. Set the value by the index: array[index] = val; Get the value by the index val = array[index]; Indexes of an array have numbers from 0 to length - 1 inclusive. Let's see an example. int numbers[] = new int[3]; // numbers: [0, 0, 0] numbers[0] = 1; // numbers: [1, 0, 0] numbers[1] = 2; // numbers: [1, 2, 0] numbers[2] = numbers[0] + numbers[1]; // numbers: [1, 2, 3] Some explanations: in the first line, the integer array named numbers with the size 3 is created. By default, all elements are equal to 0; in the second line, the value \"1\" is assigned to the first element of the array by its index (do not forget, the first element has the index 0); in the third line, the value \"2\" is assigned to the second element of the array by its index (numbers[1] - is the second element); in the last line, the sum of first two elements is assigned to the third element by its index. Note, if we try to access a non-existing element by an index then a runtime exception happens. For instance, let's try to get fourth element (with index 3) of the considered array numbers. int elem = numbers[3]; The program throws ArrayIndexOutOfBoundsException. Be careful with indexes when accessing elements of an array. All elements by loops Often, it's needed to perform some kind of algorithms on the elements of an array. For instances: sort them, find the maximum element, print only positive numbers, reverse the order, calculate the arithmetic average of numbers and so on. A convenient way to process an array is to iterate over the array using a loop. The property length of an array can help us to avoid ArrayIndexOutOfBoundsException. Example 1. Filling an array with the squares of indexes. int n = 10; // the size of an array int[] squares = new int[n]; // creating an array with the specified size System.out.println(Arrays.toString(squares)); // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] /* iterating over the array */ for (int i = 0; i < squares.length; i++) { squares[i] = i * i; // set the value by the element index } System.out.println(Arrays.toString(squares)); // [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] Some explanations. In the code above an array with the size 10 is created (filled with 0). Then each element of the array is set to the square of the element's index. Then the array is output to the standard output. Example 2. Checking the order of elements. The following program checks the given array is sorted ascending and prints \"OK\", otherwise it prints \"BROKEN\". int[] numbers = { 1, 2, 3, 4, 5, 10, 6 }; // the order is broken boolean broken = false; // suppose the array is well-ordered /* iterating over the array */ for (int i = 1; i < numbers.length; i++) { if (numbers[i] < numbers[i - 1]) { // if the order is broken broken = true; // write a result break; // terminate the loop } } System.out.println(broken ? \"BROKEN\" : \"OK\"); For the given array the program prints \"BROKEN\". To iterate over arrays while and do-while loops are also admissible, but they are used less often. Alternative: For-each loop Since Java 5 there is a special kind of the for loop called for-each. It is a special kind of the for-loop that iterates arrays and collections (they will be learned in other topics) without using indexes. Let's write a code for calculating the number of 'a' letter in the given character array. To iterate over the array we'll use for-each loop. char[] characters = { 'a', 'b', 'c', 'a', 'b', 'c', 'a' }; int counter = 0; for (char ch : characters) { if (ch == 'a') { counter++; } } System.out.println(counter); // it outputs \"3\" As you can see, the absence of indexes makes the code more readable. It also allows you to avoid ArrayIndexOutOfBoundsException. Class Arrays The class provides a lot of very useful methods for processing arrays. convert array to string using Arrays.toString(...) and then print it: byte[] famousNumbers = { 0, 1, 2, 4, 8, 16, 32, 64 }; System.out.println(Arrays.toString(famousNumbers)); // it prints [0, 1, 2, 4, 8, 16, 32, 64] sorting a whole array or a part of it: long[] bigNumbers = { 20000000000L, 40000000000L, 10000000000L, 30000000000L }; // it's unsorted Arrays.sort(bigNumbers); // sorting whole array // it prints [10000000000, 20000000000, 30000000000, 40000000000] System.out.println(Arrays.toString(bigNumbers)); comparing arrays: two arrays are equal if they contain the same elements in the same order: ```java int[] numbers1 = { 1, 2, 5, 8 }; int[] numbers2 = { 1, 2, 5 }; int[] numbers3 = { 1, 2, 5, 8 }; System.out.println(Arrays.equals(numbers1, numbers2)); // it prints \"false\" System.out.println(Arrays.equals(numbers1, numbers3)); // it prints \"true\" filling a whole array or a part of it by some values: int size = 10; char[] characters = new char[size]; // It takes an array, start index, end index (exclusive) and the value for filling the array Arrays.fill(characters, 0, size / 2, 'A'); Arrays.fill(characters, size / 2, size, 'B'); System.out.println(Arrays.toString(characters)); // it prints [A, A, A, A, A, B, B, B, B, B] Of course, the class contains a lot of other useful methods, including array copying, binary search in sorted array and so on. For details see here Samples Example 1 public class Main { public static void main(String[] args) { int[] array = { 1, 2, 3, 4 }; int length = array.length; System.out.println(length); System.out.println(array[2]); } } Example 2 import java.util.Scanner; import java.util.Arrays; public class ReadingArrayExample { public static void main(String args[]) { Scanner scanner = new Scanner(System.in); int len = scanner.nextInt(); // reading a length int[] array = new int[len]; // creating an array with the specified length for (int i = 0; i < len; i++) { array[i] = scanner.nextInt(); // read the next number of the array } System.out.println(Arrays.toString(array)); // output the array } } Example 3 import java.util.Arrays; public class WritingArrayExample { public static void main(String[] args) { int[] llista = {1,2,3}; String[] llista2 = {\"correr\", \"menjar\"}; //Option 1: for-each for (int i : llista) { System.out.print(i + \" \"); } System.out.println(); //Option 2: toString de la classe Arrays) System.out.println(Arrays.toString(llista)); //Option 3: classic for for (int i = 0; i < llista.length; i++) { System.out.print(llista[i] + \" \"); } System.out.println(); } } Example 4 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scan = new Scanner(System.in); System.out.println(\"Enter number of students:\"); int n = scan.nextInt(); int[] marks = new int[n]; int sum=0; for(int i=0; i < n; i++){ System.out.println(\"Enter marks of student \" + (i+1) +\":\"); marks[i] = scan.nextInt(); sum+=marks[i]; } System.out.println(\"Mitjana : \" + (float)sum/n); } }","title":"Arrays"},{"location":"4.1.arrays/#arrays","text":"An array is an ordered collection of elements of the same type. It can store only a fixed number of elements. The length of an array is established when the array is created. Arrays allow you to group and processing similar data together. In the following picture, an array of five floating-point elements is presented. An array of five int elements Some features: an array is a reference type; all elements are stored in the memory sequentially ; each element of an array is accessed by its numerical index, the first element has the index 0; the last element is accessed by the index equal to array size - 1; it's possible to create an array of any types; the maximum size of an array is limited by the Integer.MAX_VALUE;","title":"Arrays"},{"location":"4.1.arrays/#1st-step-declaration-instantiation-initialization","text":"To create an array filled with useful elements we should: declare a variable of an array type (declaration); create an instance of the array object (instantiation); initialize the array by some values (initialization).","title":"1st Step: Declaration, instantiation, initialization"},{"location":"4.1.arrays/#declaration","text":"To declare an array we must use two special characters [] after the name of the type of elements in the array: int[] array; // declaration ``` or after the name of an array variable: ```java int array[]; // declaration","title":"Declaration"},{"location":"4.1.arrays/#creating-an-array-with-the-specified-elements","text":"Java provides several ways to create an array. The simplest way to instantiate and initialize an array is to enumerate all its elements: int[] numbers = { 1, 2, 3, 4 }; // an array of 1, 2, 3, 4 But, this way to create an array has some disadvantages: we need to know values and number of elements at the moment of compilation. Another way is to initialize an array using variables: int a = ..., b = ..., c = ...; int[] numbers = { a, b, c }; In this case, we should have all elements at the moment of the array creation.","title":"Creating an array with the specified elements"},{"location":"4.1.arrays/#creating-an-array-using-the-keyword-new","text":"The most general way to create an instance (object) of an array is to use the special keyword new and specify the necessary number of elements: int n = ...; // n is a length of an array int[] numbers = new int[n]; Now, the array has n elements. Each element is equal to 0 (the default value). Next, we should make explicit initialization of elements. It's possible to separate declaration and instantiation in two lines: int[] numbers; numbers = new int[n]; Also, we can write the keyword new and enumerate all elements of an array: float[] floatNumbers; // declaration floatNumbers = new float[] { 1.02f, 0.03f, 4f } // instantiation and initialization","title":"Creating an array using the keyword \"new\""},{"location":"4.1.arrays/#where-to-place","text":"Another feature associated with the creating of arrays is the location of characters []. char[] chars1 = new char[n]; // [] after the type char chars2[] = new char[n]; // [] after the variable Often, Java developers use the first way because it signals that an array is a special type.","title":"Where to place []?"},{"location":"4.1.arrays/#the-length-of-an-array","text":"To obtain the length of an existing array we should write arrayName.length. It returns the length of the array. Here is an example: int[] array = { 1, 2, 3, 4 }; // an array of numbers int length = array.length; // number of elements of the array System.out.println(length); // 4","title":"The length of an array"},{"location":"4.1.arrays/#2nd-step-access","text":"","title":"2nd Step: Access"},{"location":"4.1.arrays/#specific-element-by-index","text":"The values of elements of an array can be changed. To set (get) a value to (from) array the index is used. Set the value by the index: array[index] = val; Get the value by the index val = array[index]; Indexes of an array have numbers from 0 to length - 1 inclusive. Let's see an example. int numbers[] = new int[3]; // numbers: [0, 0, 0] numbers[0] = 1; // numbers: [1, 0, 0] numbers[1] = 2; // numbers: [1, 2, 0] numbers[2] = numbers[0] + numbers[1]; // numbers: [1, 2, 3] Some explanations: in the first line, the integer array named numbers with the size 3 is created. By default, all elements are equal to 0; in the second line, the value \"1\" is assigned to the first element of the array by its index (do not forget, the first element has the index 0); in the third line, the value \"2\" is assigned to the second element of the array by its index (numbers[1] - is the second element); in the last line, the sum of first two elements is assigned to the third element by its index. Note, if we try to access a non-existing element by an index then a runtime exception happens. For instance, let's try to get fourth element (with index 3) of the considered array numbers. int elem = numbers[3]; The program throws ArrayIndexOutOfBoundsException. Be careful with indexes when accessing elements of an array.","title":"Specific element by index"},{"location":"4.1.arrays/#all-elements-by-loops","text":"Often, it's needed to perform some kind of algorithms on the elements of an array. For instances: sort them, find the maximum element, print only positive numbers, reverse the order, calculate the arithmetic average of numbers and so on. A convenient way to process an array is to iterate over the array using a loop. The property length of an array can help us to avoid ArrayIndexOutOfBoundsException. Example 1. Filling an array with the squares of indexes. int n = 10; // the size of an array int[] squares = new int[n]; // creating an array with the specified size System.out.println(Arrays.toString(squares)); // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] /* iterating over the array */ for (int i = 0; i < squares.length; i++) { squares[i] = i * i; // set the value by the element index } System.out.println(Arrays.toString(squares)); // [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] Some explanations. In the code above an array with the size 10 is created (filled with 0). Then each element of the array is set to the square of the element's index. Then the array is output to the standard output. Example 2. Checking the order of elements. The following program checks the given array is sorted ascending and prints \"OK\", otherwise it prints \"BROKEN\". int[] numbers = { 1, 2, 3, 4, 5, 10, 6 }; // the order is broken boolean broken = false; // suppose the array is well-ordered /* iterating over the array */ for (int i = 1; i < numbers.length; i++) { if (numbers[i] < numbers[i - 1]) { // if the order is broken broken = true; // write a result break; // terminate the loop } } System.out.println(broken ? \"BROKEN\" : \"OK\"); For the given array the program prints \"BROKEN\". To iterate over arrays while and do-while loops are also admissible, but they are used less often.","title":"All elements by loops"},{"location":"4.1.arrays/#alternative-for-each-loop","text":"Since Java 5 there is a special kind of the for loop called for-each. It is a special kind of the for-loop that iterates arrays and collections (they will be learned in other topics) without using indexes. Let's write a code for calculating the number of 'a' letter in the given character array. To iterate over the array we'll use for-each loop. char[] characters = { 'a', 'b', 'c', 'a', 'b', 'c', 'a' }; int counter = 0; for (char ch : characters) { if (ch == 'a') { counter++; } } System.out.println(counter); // it outputs \"3\" As you can see, the absence of indexes makes the code more readable. It also allows you to avoid ArrayIndexOutOfBoundsException.","title":"Alternative: For-each loop"},{"location":"4.1.arrays/#class-arrays","text":"The class provides a lot of very useful methods for processing arrays. convert array to string using Arrays.toString(...) and then print it: byte[] famousNumbers = { 0, 1, 2, 4, 8, 16, 32, 64 }; System.out.println(Arrays.toString(famousNumbers)); // it prints [0, 1, 2, 4, 8, 16, 32, 64] sorting a whole array or a part of it: long[] bigNumbers = { 20000000000L, 40000000000L, 10000000000L, 30000000000L }; // it's unsorted Arrays.sort(bigNumbers); // sorting whole array // it prints [10000000000, 20000000000, 30000000000, 40000000000] System.out.println(Arrays.toString(bigNumbers)); comparing arrays: two arrays are equal if they contain the same elements in the same order: ```java int[] numbers1 = { 1, 2, 5, 8 }; int[] numbers2 = { 1, 2, 5 }; int[] numbers3 = { 1, 2, 5, 8 }; System.out.println(Arrays.equals(numbers1, numbers2)); // it prints \"false\" System.out.println(Arrays.equals(numbers1, numbers3)); // it prints \"true\" filling a whole array or a part of it by some values: int size = 10; char[] characters = new char[size]; // It takes an array, start index, end index (exclusive) and the value for filling the array Arrays.fill(characters, 0, size / 2, 'A'); Arrays.fill(characters, size / 2, size, 'B'); System.out.println(Arrays.toString(characters)); // it prints [A, A, A, A, A, B, B, B, B, B] Of course, the class contains a lot of other useful methods, including array copying, binary search in sorted array and so on. For details see here","title":"Class Arrays"},{"location":"4.1.arrays/#samples","text":"","title":"Samples"},{"location":"4.1.arrays/#example-1","text":"public class Main { public static void main(String[] args) { int[] array = { 1, 2, 3, 4 }; int length = array.length; System.out.println(length); System.out.println(array[2]); } }","title":"Example 1"},{"location":"4.1.arrays/#example-2","text":"import java.util.Scanner; import java.util.Arrays; public class ReadingArrayExample { public static void main(String args[]) { Scanner scanner = new Scanner(System.in); int len = scanner.nextInt(); // reading a length int[] array = new int[len]; // creating an array with the specified length for (int i = 0; i < len; i++) { array[i] = scanner.nextInt(); // read the next number of the array } System.out.println(Arrays.toString(array)); // output the array } }","title":"Example 2"},{"location":"4.1.arrays/#example-3","text":"import java.util.Arrays; public class WritingArrayExample { public static void main(String[] args) { int[] llista = {1,2,3}; String[] llista2 = {\"correr\", \"menjar\"}; //Option 1: for-each for (int i : llista) { System.out.print(i + \" \"); } System.out.println(); //Option 2: toString de la classe Arrays) System.out.println(Arrays.toString(llista)); //Option 3: classic for for (int i = 0; i < llista.length; i++) { System.out.print(llista[i] + \" \"); } System.out.println(); } }","title":"Example 3"},{"location":"4.1.arrays/#example-4","text":"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scan = new Scanner(System.in); System.out.println(\"Enter number of students:\"); int n = scan.nextInt(); int[] marks = new int[n]; int sum=0; for(int i=0; i < n; i++){ System.out.println(\"Enter marks of student \" + (i+1) +\":\"); marks[i] = scan.nextInt(); sum+=marks[i]; } System.out.println(\"Mitjana : \" + (float)sum/n); } }","title":"Example 4"},{"location":"4.2.strings/","text":"Strings and arrays Sometimes, a string looks similar to an array of characters. It's possible to convert between strings and character arrays using special methods: char[] chars = { 'A', 'B', 'C', 'D', 'E', 'F' }; String stringFromChars = String.valueOf(chars); // \"ABCDEF\" char[] charsFromString = stringFromChars.toCharArray(); // { 'A', 'B', 'C', 'D', 'E', 'F' } String theSameString = new String(stringFromChars); // \"ABCDEF\" A string can be separated by delimiters to an array of strings. To perform this, call the method split. String text = \"a long text\"; String[] parts = text.split(\" \"); // [a, long, text] The method also can take a regular expression. Iterating over a string It's possible to iterate over characters of a string using a loop (while, do-while, for-loop). See the following example. String scientistName = \"Isaac Newton\"; for (int i = 0; i < scientistName.length(); i++) { System.out.print(scientistName.charAt(i) + \" \"); // print the current character } The code outputs: I s a a c N e w t o n If you'd like to use the for-each loop, first you should convert a string to an array of characters and iterate it. String str = \"strings are not primitive types!\"; int count = 0; for (char ch : str.toCharArray()) { if (ch == ' ') { count++; } } System.out.println(count); // 4 The code above counts and prints the number of spaces in str. The result is 4.","title":"Strings"},{"location":"4.2.strings/#strings-and-arrays","text":"Sometimes, a string looks similar to an array of characters. It's possible to convert between strings and character arrays using special methods: char[] chars = { 'A', 'B', 'C', 'D', 'E', 'F' }; String stringFromChars = String.valueOf(chars); // \"ABCDEF\" char[] charsFromString = stringFromChars.toCharArray(); // { 'A', 'B', 'C', 'D', 'E', 'F' } String theSameString = new String(stringFromChars); // \"ABCDEF\" A string can be separated by delimiters to an array of strings. To perform this, call the method split. String text = \"a long text\"; String[] parts = text.split(\" \"); // [a, long, text] The method also can take a regular expression.","title":"Strings and arrays"},{"location":"4.2.strings/#iterating-over-a-string","text":"It's possible to iterate over characters of a string using a loop (while, do-while, for-loop). See the following example. String scientistName = \"Isaac Newton\"; for (int i = 0; i < scientistName.length(); i++) { System.out.print(scientistName.charAt(i) + \" \"); // print the current character } The code outputs: I s a a c N e w t o n If you'd like to use the for-each loop, first you should convert a string to an array of characters and iterate it. String str = \"strings are not primitive types!\"; int count = 0; for (char ch : str.toCharArray()) { if (ch == ' ') { count++; } } System.out.println(count); // 4 The code above counts and prints the number of spaces in str. The result is 4.","title":"Iterating over a string"},{"location":"4.3.arrays-multi/","text":"An array of arrays Some structures such as matrices and tables are conveniently modeled by two-dimensional arrays. Java provides a possibility to process two and more-dimensional arrays. To create a multi-dimensional array we should use an array as an element of another array. In this case, we create an array of arrays. To iterate over multi-dimensional arrays nested loops are often used. 2-dimensional arrays Here is an example that creates a two-dimensional array: // two-dim array - the array of arrays int[][] twoDimArray = { {1, 2, 3, 1}, // first array of int {3, 4, 1, 2}, // second array of int {4, 4, 1, 0} // third array of int }; In this case, the length of twoDimArray is 3 (because it includes 3 arrays as elements). The length of each nested array is 4. Now if you'd like to get an integer element from the array you should write two indexes: int number = twoDimArray[0][2]; // it is 3 In this case, the first index specified an element (nested array or row) of twoDimArray. The second index specified the element inside the nested array. Important, all nested arrays can have a different length. See an example below: int[][] twoDimArray = new int[3][]; twoDimArray[0] = new int[] { 1, 2, 3, 4 }; // the length is 4 twoDimArray[1] = new int[] { 5, 7, 3}; // the length is 3 twoDimArray[2] = new int[] { 8 }; // the length is 1 // let's output the array for (int i = 0; i < twoDimArray.length; i++) { System.out.println(Arrays.toString(twoDimArray[i])); } The code above outputs: [1, 2, 3, 4] [5, 7, 3] [8] 3-dimensional arrays You can create an array with more than 2 dimensional (3-dim, 4-dim, 5-dim and so on). Let's create 3-dimensional integer array: int[][][] cubic = new int[3][4][5]; Now, let's fill each 2D array of the 3D array cubic by the following rules: the first array must contain only \"1\", the second - \"2\" and so on. The implementation: // this code fills the 3-dimensional array int current = 1; for (int[][] dim2Array : cubic) { // for each 2-dim array for (int[] vector : dim2Array) { // for each 1-dim array (vector) of 2-dim array Arrays.fill(vector, current); // fill the vector } current++; // the next current } // this code prints all 2-dimensional arrays for (int[][] dim2Array : cubic) { for (int[] vector : dim2Array) { System.out.println(Arrays.toString(vector)); } System.out.println(); } This code prints three 2-dim arrays: [1, 1, 1, 1, 1] [1, 1, 1, 1, 1] [1, 1, 1, 1, 1] [1, 1, 1, 1, 1] [2, 2, 2, 2, 2] [2, 2, 2, 2, 2] [2, 2, 2, 2, 2] [2, 2, 2, 2, 2] [3, 3, 3, 3, 3] [3, 3, 3, 3, 3] [3, 3, 3, 3, 3] [3, 3, 3, 3, 3] Sample import java.util.Scanner; public class Main { public static void main(String[] args) { float[][] a = new float[2][2]; float[][] b = new float[2][2]; float[][] c = new float[2][2]; Scanner in = new Scanner(System.in); System.out.println(\"Introdueix els elements de la 1a matriu:\"); /* Reading two dimensional Array with the help of two for loop. If there was an array of 'n' dimension, 'n' numbers of loops are needed for inserting data to array.*/ for(int i = 0; i < 2 ; i++) { for(int j = 0; j < 2; j++){ System.out.print(\"Enter \"+ (i + 1) + \" \"+ (j + 1) + \": \"); a[i][j] = in.nextInt(); } } System.out.println(\"Introdueix els elements de la 2n matriu: \"); for(int i = 0 ; i < 2 ; i++) { for ( int j = 0; j < 2; j++) { System.out.print(\"Enter \" + (i + 1) + \" \" + (j + 1) + \": \"); b[i][j] = in.nextInt(); } } System.out.println(\"La 3a matriu ser\u00e0 el sumatori posici\u00f3 a posici\u00f3 de la 1a i la 2a matrius.\"); for(int i = 0; i < 2 ; i++) { for (int j = 0; j < 2; j++) { c[i][j] = a[i][j] + b[i][j]; } } System.out.println(\"La 3a matriu queda:\"); for(int i = 0; i < 2 ; i++) { for (int j = 0; j < 2; j++) { System.out.print(String.format(\"%5.0f\",c[i][j])); } System.out.println(); } } }","title":"Multi-dimensional Arrays"},{"location":"4.3.arrays-multi/#an-array-of-arrays","text":"Some structures such as matrices and tables are conveniently modeled by two-dimensional arrays. Java provides a possibility to process two and more-dimensional arrays. To create a multi-dimensional array we should use an array as an element of another array. In this case, we create an array of arrays. To iterate over multi-dimensional arrays nested loops are often used.","title":"An array of arrays"},{"location":"4.3.arrays-multi/#2-dimensional-arrays","text":"Here is an example that creates a two-dimensional array: // two-dim array - the array of arrays int[][] twoDimArray = { {1, 2, 3, 1}, // first array of int {3, 4, 1, 2}, // second array of int {4, 4, 1, 0} // third array of int }; In this case, the length of twoDimArray is 3 (because it includes 3 arrays as elements). The length of each nested array is 4. Now if you'd like to get an integer element from the array you should write two indexes: int number = twoDimArray[0][2]; // it is 3 In this case, the first index specified an element (nested array or row) of twoDimArray. The second index specified the element inside the nested array. Important, all nested arrays can have a different length. See an example below: int[][] twoDimArray = new int[3][]; twoDimArray[0] = new int[] { 1, 2, 3, 4 }; // the length is 4 twoDimArray[1] = new int[] { 5, 7, 3}; // the length is 3 twoDimArray[2] = new int[] { 8 }; // the length is 1 // let's output the array for (int i = 0; i < twoDimArray.length; i++) { System.out.println(Arrays.toString(twoDimArray[i])); } The code above outputs: [1, 2, 3, 4] [5, 7, 3] [8]","title":"2-dimensional arrays"},{"location":"4.3.arrays-multi/#3-dimensional-arrays","text":"You can create an array with more than 2 dimensional (3-dim, 4-dim, 5-dim and so on). Let's create 3-dimensional integer array: int[][][] cubic = new int[3][4][5]; Now, let's fill each 2D array of the 3D array cubic by the following rules: the first array must contain only \"1\", the second - \"2\" and so on. The implementation: // this code fills the 3-dimensional array int current = 1; for (int[][] dim2Array : cubic) { // for each 2-dim array for (int[] vector : dim2Array) { // for each 1-dim array (vector) of 2-dim array Arrays.fill(vector, current); // fill the vector } current++; // the next current } // this code prints all 2-dimensional arrays for (int[][] dim2Array : cubic) { for (int[] vector : dim2Array) { System.out.println(Arrays.toString(vector)); } System.out.println(); } This code prints three 2-dim arrays: [1, 1, 1, 1, 1] [1, 1, 1, 1, 1] [1, 1, 1, 1, 1] [1, 1, 1, 1, 1] [2, 2, 2, 2, 2] [2, 2, 2, 2, 2] [2, 2, 2, 2, 2] [2, 2, 2, 2, 2] [3, 3, 3, 3, 3] [3, 3, 3, 3, 3] [3, 3, 3, 3, 3] [3, 3, 3, 3, 3]","title":"3-dimensional arrays"},{"location":"4.3.arrays-multi/#sample","text":"import java.util.Scanner; public class Main { public static void main(String[] args) { float[][] a = new float[2][2]; float[][] b = new float[2][2]; float[][] c = new float[2][2]; Scanner in = new Scanner(System.in); System.out.println(\"Introdueix els elements de la 1a matriu:\"); /* Reading two dimensional Array with the help of two for loop. If there was an array of 'n' dimension, 'n' numbers of loops are needed for inserting data to array.*/ for(int i = 0; i < 2 ; i++) { for(int j = 0; j < 2; j++){ System.out.print(\"Enter \"+ (i + 1) + \" \"+ (j + 1) + \": \"); a[i][j] = in.nextInt(); } } System.out.println(\"Introdueix els elements de la 2n matriu: \"); for(int i = 0 ; i < 2 ; i++) { for ( int j = 0; j < 2; j++) { System.out.print(\"Enter \" + (i + 1) + \" \" + (j + 1) + \": \"); b[i][j] = in.nextInt(); } } System.out.println(\"La 3a matriu ser\u00e0 el sumatori posici\u00f3 a posici\u00f3 de la 1a i la 2a matrius.\"); for(int i = 0; i < 2 ; i++) { for (int j = 0; j < 2; j++) { c[i][j] = a[i][j] + b[i][j]; } } System.out.println(\"La 3a matriu queda:\"); for(int i = 0; i < 2 ; i++) { for (int j = 0; j < 2; j++) { System.out.print(String.format(\"%5.0f\",c[i][j])); } System.out.println(); } } }","title":"Sample"},{"location":"5.1.functions/","text":"What is a function? A function is a set of instructions grouped together to perform a specific task. A program in Java has at least one main () function. Basically, there are two types of functions in Java, those of libraries (which are imported and used, such as: println, sqrt, round, nextLine ...) and those that are created by the user. The ones we will work on in this blog are the ones created by the user. Its syntax is as follows: private static void function_name(){ ................ ................ } public static void main(String[] args){ ........... ........... function_name(); ........... ........... } Structure To work with functions in Java we need: The creation of the function itself (contains the code to perform the task): private static return_type function_name (type (1) argument (1), .., type (n) argument (n)) { // body of function } Your call within the main or other function (to use it): function_name (argument (1), .... argument (n)); Advantages They help break down the problem into small blocks of code that are easier to understand, maintain, and debug. They avoid code redundancy if it has to be repeated. The workload can be divided into different functions. Example import java.util.Scanner; public class Example { private static int add (int a, int b) {// function declarator / * Start of function definition. * / int add; add = a + b; return add; // return statement of function / * End of function definition. * / } public static void main (String [] args) { int num1, num2, sum; Scanner in = new Scanner (System.in); System.out.println (\"Enters two number to add\"); num1 = in.nextInt (); num2 = in.nextInt (); sum = add (num1, num2); // function call System.out.println (\"Sum =\" + sum); } }","title":"Functions"},{"location":"5.1.functions/#what-is-a-function","text":"A function is a set of instructions grouped together to perform a specific task. A program in Java has at least one main () function. Basically, there are two types of functions in Java, those of libraries (which are imported and used, such as: println, sqrt, round, nextLine ...) and those that are created by the user. The ones we will work on in this blog are the ones created by the user. Its syntax is as follows: private static void function_name(){ ................ ................ } public static void main(String[] args){ ........... ........... function_name(); ........... ........... }","title":"What is a function?"},{"location":"5.1.functions/#structure","text":"To work with functions in Java we need: The creation of the function itself (contains the code to perform the task): private static return_type function_name (type (1) argument (1), .., type (n) argument (n)) { // body of function } Your call within the main or other function (to use it): function_name (argument (1), .... argument (n));","title":"Structure"},{"location":"5.1.functions/#advantages","text":"They help break down the problem into small blocks of code that are easier to understand, maintain, and debug. They avoid code redundancy if it has to be repeated. The workload can be divided into different functions.","title":"Advantages"},{"location":"5.1.functions/#example","text":"import java.util.Scanner; public class Example { private static int add (int a, int b) {// function declarator / * Start of function definition. * / int add; add = a + b; return add; // return statement of function / * End of function definition. * / } public static void main (String [] args) { int num1, num2, sum; Scanner in = new Scanner (System.in); System.out.println (\"Enters two number to add\"); num1 = in.nextInt (); num2 = in.nextInt (); sum = add (num1, num2); // function call System.out.println (\"Sum =\" + sum); } }","title":"Example"},{"location":"5.2.testing/","text":"Testing We will use JUnit to test the quality of our functions in a very simple way. Sample Base class with sum and power functions: package exercicis; import java.util.Scanner; public class IntroFuncions { public static int potencia(int base, int exp) { int resultat = 1; for(int i = 0; i < exp; i++) { resultat *= base; } return resultat; } public static int suma(int a, int b) { return a+b; } public static void main(String[] args) { Scanner in = new Scanner(System.in); System.out.println(\"Introdueix dos n\u00fameros:\"); int a = in.nextInt(); int b = in.nextInt(); System.out.println(\"El resultat de la seva pot\u00e8ncia \u00e9s: \" + potencia(a,b)); System.out.println(\"El resultat de la seva suma \u00e9s: \" + suma(a,b)); } } Testing Class with JUnit: package test; import exercicis.IntroFuncions; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; class IntroFuncionsTest { @Test void potencia() { assertEquals(25, IntroFuncions.potencia(5,2)); assertEquals(125, IntroFuncions.potencia(5,3)); assertNotEquals(24, IntroFuncions.potencia(5,2)); } @Test void suma() { assertEquals(7, IntroFuncions.suma(5,2)); assertNotEquals(8, IntroFuncions.suma(5,11)); } } JUnit Testing functions fail([message]) Let the method fail. Might be used to check that a certain part of the code is not reached or to have a failing test before the test code is implemented. The message parameter is optional. assertTrue([message,] boolean condition) Checks that the boolean condition is true. assertFalse([message,] boolean condition) Checks that the boolean condition is false. assertEquals([message,] expected, actual) Tests that two values are the same. Note: for arrays the reference is checked not the content of the arrays. assertEquals([message,] expected, actual, tolerance) Test that float or double values match. The tolerance is the number of decimals which must be the same. assertNull([message,] object) Checks that the object is null. assertNotNull([message,] object) Checks that the object is not null. assertSame([message,] expected, actual) Checks that both variables refer to the same object. assertNotSame([message,] expected, actual) Checks that both variables refer to different objects. Generation of a Testing class with JUnit Explanation with the IntelliJ IDEA Remember, we will press \"ALT + Enter\" in the base class definition and choose the \"Create Test\" option. Tests will always be stored in a package separate from the base class called \"test\".","title":"Testing"},{"location":"5.2.testing/#testing","text":"We will use JUnit to test the quality of our functions in a very simple way.","title":"Testing"},{"location":"5.2.testing/#sample","text":"Base class with sum and power functions: package exercicis; import java.util.Scanner; public class IntroFuncions { public static int potencia(int base, int exp) { int resultat = 1; for(int i = 0; i < exp; i++) { resultat *= base; } return resultat; } public static int suma(int a, int b) { return a+b; } public static void main(String[] args) { Scanner in = new Scanner(System.in); System.out.println(\"Introdueix dos n\u00fameros:\"); int a = in.nextInt(); int b = in.nextInt(); System.out.println(\"El resultat de la seva pot\u00e8ncia \u00e9s: \" + potencia(a,b)); System.out.println(\"El resultat de la seva suma \u00e9s: \" + suma(a,b)); } } Testing Class with JUnit: package test; import exercicis.IntroFuncions; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; class IntroFuncionsTest { @Test void potencia() { assertEquals(25, IntroFuncions.potencia(5,2)); assertEquals(125, IntroFuncions.potencia(5,3)); assertNotEquals(24, IntroFuncions.potencia(5,2)); } @Test void suma() { assertEquals(7, IntroFuncions.suma(5,2)); assertNotEquals(8, IntroFuncions.suma(5,11)); } }","title":"Sample"},{"location":"5.2.testing/#junit-testing-functions","text":"fail([message]) Let the method fail. Might be used to check that a certain part of the code is not reached or to have a failing test before the test code is implemented. The message parameter is optional. assertTrue([message,] boolean condition) Checks that the boolean condition is true. assertFalse([message,] boolean condition) Checks that the boolean condition is false. assertEquals([message,] expected, actual) Tests that two values are the same. Note: for arrays the reference is checked not the content of the arrays. assertEquals([message,] expected, actual, tolerance) Test that float or double values match. The tolerance is the number of decimals which must be the same. assertNull([message,] object) Checks that the object is null. assertNotNull([message,] object) Checks that the object is not null. assertSame([message,] expected, actual) Checks that both variables refer to the same object. assertNotSame([message,] expected, actual) Checks that both variables refer to different objects.","title":"JUnit Testing functions"},{"location":"5.2.testing/#generation-of-a-testing-class-with-junit","text":"Explanation with the IntelliJ IDEA Remember, we will press \"ALT + Enter\" in the base class definition and choose the \"Create Test\" option. Tests will always be stored in a package separate from the base class called \"test\".","title":"Generation of a Testing class with JUnit"},{"location":"6.recursion/","text":"Recursion A recursive function is one that calls itself. Every recursive function will have a base case of completion and an alternative case of continuation because otherwise the calls itself would be executed infinitely. private static tipusRetorn functionName( ...){ if ( ) { return valorDelTipusRetorn; } else { return functionName(...); } } public static void main(String[] args){ ........... ........... functionName(...); ........... ........... } Samples import java.util.Scanner; public class FactorialRecursiu { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.print(\"Introdueix un n\u00famero: \"); int num = sc.nextInt(); System.out.println(\"\\nEl factorial de \" + num + \" \u00e9s: \" + factorial(num)); } public static int factorial(int num){ if (num == 0) { return 1; } else { return num * factorial(num-1); } } } import java.util.Scanner; public class FibonacciRecursiu { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.print(\"Introdueix el n\u00famero de elements a mostrar de la serie: \"); int limite = sc.nextInt(); for(int i = 0; i<limite; i++){ System.out.print(fibonacci(i) + \", \"); } } private static int fibonacci(int num){ if (num == 0 || num==1) { return num; } else { return fibonacci(num-1) + fibonacci(num-2); } } }","title":"Recursion"},{"location":"6.recursion/#recursion","text":"A recursive function is one that calls itself. Every recursive function will have a base case of completion and an alternative case of continuation because otherwise the calls itself would be executed infinitely. private static tipusRetorn functionName( ...){ if ( ) { return valorDelTipusRetorn; } else { return functionName(...); } } public static void main(String[] args){ ........... ........... functionName(...); ........... ........... }","title":"Recursion"},{"location":"6.recursion/#samples","text":"import java.util.Scanner; public class FactorialRecursiu { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.print(\"Introdueix un n\u00famero: \"); int num = sc.nextInt(); System.out.println(\"\\nEl factorial de \" + num + \" \u00e9s: \" + factorial(num)); } public static int factorial(int num){ if (num == 0) { return 1; } else { return num * factorial(num-1); } } } import java.util.Scanner; public class FibonacciRecursiu { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.print(\"Introdueix el n\u00famero de elements a mostrar de la serie: \"); int limite = sc.nextInt(); for(int i = 0; i<limite; i++){ System.out.print(fibonacci(i) + \", \"); } } private static int fibonacci(int num){ if (num == 0 || num==1) { return num; } else { return fibonacci(num-1) + fibonacci(num-2); } } }","title":"Samples"},{"location":"resumMarkDown/","text":"Introduction TIOBE index Short history ```java class Task { public static void main(String[] args) { // The line below will be ignored // System.out.println(\"Hello, World\"); // It prints the string \"Hello, Java\" System.out.println(\"Hello, Java\"); // You can write a comment here } } ``","title":"Introduction"},{"location":"resumMarkDown/#introduction","text":"TIOBE index","title":"Introduction"},{"location":"resumMarkDown/#short-history","text":"```java class Task { public static void main(String[] args) { // The line below will be ignored // System.out.println(\"Hello, World\"); // It prints the string \"Hello, Java\" System.out.println(\"Hello, Java\"); // You can write a comment here } } ``","title":"Short history"}]}